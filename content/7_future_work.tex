\chapter{Future Work} \label{sec:FUTURE_WORK}

In the future, we want to improve the practicability of our implementation.

In addition, we would like to build upon it.
The system should preserve meaningful versions of the runtime automatically and support developers in finding relevant previous state in recovery situations.

performance of the implementation could also improve through faster proxies

proxies do not necessarily have to be used to access all mutable state, temporary mutable state as, for example, by the object-oriented OMeta parser used in Lively does not need to be versioned. 
given Chrome's single-threaded and cooperative execution of JavaScript code, it is not possible to preserve or change the version of the runtime during parsing, anyway..

\section{Improving the Performance of Our JavaScript Implementation}

\begin{itemize}
    \item lookup-indirection-microbenchmark… proxy-akin indirection vs. direct reference...
\end{itemize}

source-rewrite-approach.. source code transformations instead of proxies

anObject.aProperty() -> apply(anObject, get(anObject, aProperty))


\section{Providing Continuous Object Versioning with Recovery Support Tools}

\begin{itemize}
    \item continuous versioning: versions whenever a user (might) trigger side effects, with each trigger that (might) effects some state: direct manipulation of morphs with halo buttons, evaluation of do-it code snippets, saving scripts or methods, mouse events that fire up code execution.
on a granularity meaningful to the user, so he knows he can take back his actions on the system.
    \item finding relevant versions: see what triggered a version (do-it, halo button, save button, application button)?, when the version was created (screenshot, screencast)?, how it is related to other versions (time line of versions)?, what has changed? which object(s) (morph names, structural context a la morph composition or related named morphs)? how can these objects be identified? how where objects changed (state diff, code diff)?, what is the impact of the changes (test results, benchmark results)?
    \item ability to revisit the or one of the previous versions,fine-grained version control to be able to recover versions of particular objects from previous versions of the runtime (cherry-picking), branching from a previous version, merging branches… diffing versions of objects… high-level summary of the differences between versions of the runtime
\end{itemize}
