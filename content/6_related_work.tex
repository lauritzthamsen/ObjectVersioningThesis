\chapter{Related Work} \label{sec:RELATED_WORK}

\todo{section intro for related work}

\todo{is Johnson and Duggan’s GL programming language related work? (see worlds paper)}
\todo{are Morrisett sub-stores related work? (see worlds papers)}



\section{CoExist}

\cite{Steinert2012COE}
CoExist provides recovery support through continuous versioning in Squeak/Smalltalk.
For each change made to source code, CoExist creates a new version of the system sources, resulting in a fine-grained history of changes.
CoExist then presents this fine-grained history in a timeline and a browser.
For each version, those tools provide diffs, but also test results and a screenshot.
That is, developers do not need to take precautionary actions explicitly during development, but still can easily recover previous development states.
Developers can concentrate on implementing their ideas and as CoExist records a version for each change, there is also no possibility that developers miss a version they need later-on.

Both CoExist and our object versioning record and manage multiple versions of the development state.
They have in common that preserved versions are also part of the program runtime and that versions can be re-established easily.
However, CoExist already records versions continuously on the granularity of changes made by developers and provides much more tool support to find and recover changes from previous versions, which we want to provide for our implementation and the Lively Kernel in the future.
In contrast to CoExist, our system not only preserves code, but also the state of objects and, thus, is primarily intended for programming systems that allow to manipulate objects directly.


\section{Worlds}

Worlds are a language construct to capture and control the scope of side-effects: changes to the state of objects are by default only effective in the world in which the changes occurred.
Worlds are first-class values, to be used to execute statements in a particular world.
A new world can be spawned from an existing world, which establishes a child-parent relationships between the two worlds.
Developers can commit changes contained in a child world to its parent world, thereby extending the scope of the captured side-effects.
For this, the Worlds approach further includes conditions to prevent inconsistencies as result of commits.

In comparison, Worlds provides a language construct to support explicitly experimenting with different states of the runtime, while object versioning provides versions of the runtime intented to be created implicitly and continuously: Our approach does not include extensions to existing programming languages with versions as first-class values and no conditions under which versions of the runtime should be merged into their predecessors.

That said, worlds could, potentially, also be used as a basis for continuous object versioning.
However, out of practical considerations---currently, Worlds, for example, provides no garbage collection and also does not work for all possible JavaScript code---we decided not to build upon worlds, but to implement object versioning as explained in Section~\ref{sec:IMPLEMENTATION}.


\section{Offline Worlds}
Offline Worlds~\cite{Czuchra2012OfW}, automatically saving worlds in a fixed interval

intend: Browser- oder Betriebssystem-Abstuerzen, Netzwerk- oder Server-Ausfaellen, so- wie gleichzeitigen Aenderungen durch andere Nutzer fuehrt
vs. recover from changes that turn out to be inappropriate (single user, single session..)

in an interval: Offline Worlds store progress automatically based on an interval that is set to 10 seconds...

implementation differences: serializing worlds vs. copy-on-write versions of objects of the runtime: creating new versions (serialization and diffing to gain world version deltas) and revisiting older versions (loading older worlds from scratch) should be considerable slower, interruptive / stop-the-world, whereas with our approach the overhead for new versions or revisting is less and also more incremental than stop-the-world (new versions of the runtime with essentially no cost at that point in time, but new versions of objects only when we write to them, reusing older versions on an object granularity, and not resetting all objects to a previous version, but dynamically resolving to the correct version whenever references are followed..), but Martins approach has no basic execution overhead, just way more costly and interruptive commit/undo operations... in comparsion, our approach might be more suited for very fine-grained object versioning, while Martins might be more suited for the occasional snapshot of the world..



\section{Back-in-Time Debugging}

back-in-time debugging~\cite{Lewis2003BIT}
Logging-based approaches, Replay-based approaches \todo{see Lienhard2008POB}.. to recreate a particular state of the runtime... but purpose is debugging and not necessarily recovering.. 

Practical Back-in-Time Debugging~\cite{Lienhard2008POB}, Aliases (Lienhard Diss): the idea of using objects for references that hold more information on objects, including information on the objects past, which are called object aliases in this work, is very similar to our version-aware references. including the idea to rely on the usual garbage collection to take care of versions for an unreachable object

different intent: only debugging vs. undo/redo during usage

different approach to when to create these references… not at object creation, but more appropriate for following a single execution flow (without preparing the rest of the system)



\section{ChangeBoxes}
ChangeBoxes~\cite{Denker2007EEC}

Class-boxes? \todo{what about Alexandre Bergel's Class-boxes.. and other boxes by the SCG?}



\section{Subject-oriented Programming}
maybe something about David Ungar's Us~\cite{}



\section{Context-oriented Programming}
Context-oriented Programming~\cite{Hirschfeld2008COP}

ContextJS~\cite{Lincke2011OIC}, scoping changes in a self-supporting system~\cite{Lincke2012SCS}


\section{Software Transactional Memory}
Software Transactional Memory~\cite{Shavit1995STM}



\section{Scoped Assignments}
Tanter's scoped assignment construct  that enables programmers to control the scope of side effects 



