\chapter{Related Work} \label{sec:RELATED_WORK}

\todo{section intro for related work}

\todo{is Johnson and Duggan’s GL programming language related work? (see worlds paper)}
\todo{are Morrisett sub-stores related work? (see worlds papers)}



\section{CoExist}

\cite{Steinert2012COE}
CoExist provides recovery support through continuous versioning in Squeak/Smalltalk.
For each change made to source code, CoExist creates a new version of the system sources, resulting in a fine-grained history of changes.
CoExist then presents this fine-grained history in a timeline and a browser.
For each version, those tools provide diffs, but also test results and a screenshot.
That is, developers do not need to take precautionary actions explicitly during development, but still can easily recover previous development states.
Developers can concentrate on implementing their ideas and as CoExist records a version for each change, there is also no possibility that developers miss a version they need later-on.

Both CoExist and our object versioning record and manage multiple versions of the development state.
They have in common that preserved versions are also part of the program runtime and that versions can be re-established easily.
However, CoExist already records versions continuously on the granularity of changes made by developers and provides much more tool support to find and recover changes from previous versions, which we want to provide for our implementation and the Lively Kernel in the future.
In contrast to CoExist, our system not only preserves code, but also the state of objects and, thus, is primarily intended for programming systems that allow to manipulate objects directly.



\section{Worlds}

Worlds are a language construct to capture and control the scope of side-effects: changes to the state of objects are by default only effective in the world in which the changes occurred.
Worlds are first-class values, to be used to execute statements in a particular world.
A new world can be spawned from an existing world, which establishes a child-parent relationships between the two worlds.
Developers can commit changes contained in a child world to its parent world, thereby extending the scope of the captured side-effects.
For this, the Worlds approach further includes conditions to prevent inconsistencies as result of commits.

In comparison, Worlds provides a language construct to support explicitly experimenting with different states of the runtime, while object versioning provides versions of the runtime intented to be created implicitly and continuously: Our approach does not include extensions to existing programming languages with versions as first-class values and no conditions under which versions of the runtime should be merged into their predecessors.

That said, worlds could, potentially, also be used as a basis for continuous object versioning.
However, out of practical considerations---currently, Worlds, for example, provides no garbage collection and also does not work for all possible JavaScript code---we decided not to build upon worlds, but to implement object versioning as explained in Section~\ref{sec:IMPLEMENTATION}.



\section{Offline Worlds}

Offline Worlds~\cite{Czuchra2012OfW} is an approach to implementing automatic saving of Lively worlds as protection against system failures.
The world is saved automatically in a fixed time interval to be able to re-establish the latest saved version of the world in case of unexpected crashes, or network or server outages.

As only the differences to the last saved version is stored, Offline Worlds would also allow to re-establish other versions than the latest.
However, in contrast to our goals, the Offline Worlds approach aims at preserving the latest state of a Lively world to provide recovery from system failures, while our approach aims to preserve multiple versions of the runtime to provide recovery from inappropriate changes.
Further, Offline Worlds only preserve the state of all graphical objects, whereas our versions also preserve other globally accessible state such as the global system configuration, classes, and state explicitly excluded when serializing graphical objects.
Also, while our approach saves new versions incrementally and resolves to different versions dynamically, Offline Worlds saves and loads versions of the world in a discrete, interruptive step.
While object versioning introduces a constant execution overhead for resolving version-aware references, Offline Worlds stops the world for both saving and loading versions.
For this reason, object versioning seems to be more practical for fine-grained versioning.



\section{Back-in-Time Debugging}

back-in-time debugging~\cite{Lewis2003BIT}
Logging-based approaches, Replay-based approaches \todo{see Lienhard2008POB}.. to recreate a particular state of the runtime... but purpose is debugging and not necessarily recovering.. 

Practical Back-in-Time Debugging~\cite{Lienhard2008POB}, Aliases (Lienhard Diss): the idea of using objects for references that hold more information on objects, including information on the objects past, which are called object aliases in this work, is very similar to our version-aware references. including the idea to rely on the usual garbage collection to take care of versions for an unreachable object

different intent: only debugging vs. undo/redo during usage

different approach to when to create these references… not at object creation, but more appropriate for following a single execution flow (without preparing the rest of the system)



\section{ChangeBoxes}
ChangeBoxes~\cite{Denker2007EEC}

Class-boxes? \todo{what about Alexandre Bergel's Class-boxes.. and other boxes by the SCG?}



\section{Subject-oriented Programming}
maybe something about David Ungar's Us~\cite{}



\section{Context-oriented Programming}
Context-oriented Programming~\cite{Hirschfeld2008COP}

ContextJS~\cite{Lincke2011OIC}, scoping changes in a self-supporting system~\cite{Lincke2012SCS}


\section{Software Transactional Memory}
Software Transactional Memory~\cite{Shavit1995STM}



\section{Scoped Assignments}
Tanter's scoped assignment construct  that enables programmers to control the scope of side effects 



