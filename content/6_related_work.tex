\chapter{Related Work} \label{sec:RELATED_WORK}

\todo{section intro for related work}

\todo{is Johnson and Duggan’s GL programming language related work? (see worlds paper)}
\todo{are Morrisett sub-stores related work? (see worlds papers)}



\section{CoExist}

\cite{Steinert2012COE}
CoExist provides recovery support through continuous versioning in Squeak/Smalltalk.
For each change made to source code, CoExist creates a new version of the system sources, resulting in a fine-grained history of changes.
CoExist then presents this fine-grained history in a timeline and a browser.
For each version, those tools provide diffs, but also test results and a screenshot.
That is, developers do not need to take precautionary actions explicitly during development, but still can easily recover previous development states.
Developers can concentrate on implementing their ideas and as CoExist records a version for each change, there is also no possibility that developers miss a version they need later-on.

Both CoExist and our object versioning record and manage multiple versions of the development state.
They have in common that preserved versions are also part of the program runtime and that versions can be re-established easily.
However, CoExist already records versions continuously on the granularity of changes made by developers and provides much more tool support to find and recover changes from previous versions, which we want to provide for our implementation and the Lively Kernel in the future.
In contrast to CoExist, our system not only preserves code, but also the state of objects and, thus, is primarily intended for programming systems that allow to manipulate objects directly.


\section{Worlds}

(language construct to capture side-effects of statements into worlds. worlds are first-class values. new worlds can be created from existing worlds, which also establishes a parent relationship, so that worlds can be commited to their parents again. both sprouting new worlds and commiting the side effects of inheriting worlds back to their parent worlds is explicit. as is the management of world values. a programming tool to support explicit experimentation and a basis for multiple application, including undo/redo for particular application. but explicit capturing of side-effects instead continuous capturing of versions. 
worlds could be a basis for implementing continuous versioning… but implementation of Worlds/JS is not quite practical for our goals: no garbage collection with global worlds tables, relies on OMeta (interferes with debugging / exception listening, doesn’t provide source maps, proxies have advantages..)



\section{Offline Worlds}
Offline Worlds~\cite{Czuchra2012OfW}, automatically saving worlds in a fixed interval

intend: Browser- oder Betriebssystem-Abstuerzen, Netzwerk- oder Server-Ausfaellen, so- wie gleichzeitigen Aenderungen durch andere Nutzer fuehrt
vs. recover from changes that turn out to be inappropriate (single user, single session..)

in an interval: Offline Worlds store progress automatically based on an interval that is set to 10 seconds...

implementation differences: serializing worlds vs. copy-on-write versions of objects of the runtime: creating new versions (serialization and diffing to gain world version deltas) and revisiting older versions (loading older worlds from scratch) should be considerable slower, interruptive / stop-the-world, whereas with our approach the overhead for new versions or revisting is less and also more incremental than stop-the-world (new versions of the runtime with essentially no cost at that point in time, but new versions of objects only when we write to them, reusing older versions on an object granularity, and not resetting all objects to a previous version, but dynamically resolving to the correct version whenever references are followed..), but Martins approach has no basic execution overhead, just way more costly and interruptive commit/undo operations... in comparsion, our approach might be more suited for very fine-grained object versioning, while Martins might be more suited for the occasional snapshot of the world..



\section{Back-in-Time Debugging}

back-in-time debugging~\cite{Lewis2003BIT}
Logging-based approaches, Replay-based approaches \todo{see Lienhard2008POB}.. to recreate a particular state of the runtime... but purpose is debugging and not necessarily recovering.. 

Practical Back-in-Time Debugging~\cite{Lienhard2008POB}, Aliases (Lienhard Diss): the idea of using objects for references that hold more information on objects, including information on the objects past, which are called object aliases in this work, is very similar to our version-aware references. including the idea to rely on the usual garbage collection to take care of versions for an unreachable object

different intent: only debugging vs. undo/redo during usage

different approach to when to create these references… not at object creation, but more appropriate for following a single execution flow (without preparing the rest of the system)



\section{ChangeBoxes}
ChangeBoxes~\cite{Denker2007EEC}

Class-boxes? \todo{what about Alexandre Bergel's Class-boxes.. and other boxes by the SCG?}



\section{Subject-oriented Programming}
maybe something about David Ungar's Us~\cite{}



\section{Context-oriented Programming}
Context-oriented Programming~\cite{Hirschfeld2008COP}

ContextJS~\cite{Lincke2011OIC}, scoping changes in a self-supporting system~\cite{Lincke2012SCS}


\section{Software Transactional Memory}
Software Transactional Memory~\cite{Shavit1995STM}



\section{Scoped Assignments}
Tanter's scoped assignment construct  that enables programmers to control the scope of side effects 



