\chapter{Related Work} \label{chapter:RELATED_WORK}

This chapter presents two categories of related work:

\begin{enumerate}
    \item Approaches related to our motivation and, thus, to providing access to previous versions of the system state.
    \item Approaches related to technical solution and, thus, to combining changes into first-class objects that can be used to scope changes dynamically.
\end{enumerate}


\section{Recovery of Previous System States}

The approaches presented in this section support programmers in recovering previous states without requiring programmers to create snapshots in advance.


\subsection{CoExist}

CoExist~\cite{Steinert2012COE} provides recovery support through continuous versioning in Squeak/Smalltalk.
For each change made to source code, CoExist creates a new version of the system sources, resulting in a fine-grained history of changes.
CoExist presents this history in a timeline tool and a dedicated browser.
For each version, those tools show the changes, test results, and a screenshot.
Developers can recover previous development states, even without taking precautionary actions beforehand.
This way, developers can concentrate on implementing their ideas and let CoExist record the required versions to be able to recover when necessary.

Both CoExist and our approach to object versioning allow multiple versions of the development state to coexist.
With both approaches, preserved versions are also part of the program runtime and can be re-established easily.
Currently only CoExist records versions continuously on the granularity of changes made by developers.
CoExist also provides much more tool support to find and recover changes from previous versions.
However, CoExist recognizes only changes to the source code of classes, while our system preserves the state and behavior of objects.


\subsection{Lively Kernel Offline Worlds}

Offline Worlds~\cite{Czuchra2012OfW} is an approach to protect state against system failures by saving it periodically.
In a fixed time interval the current Lively Kernel world is saved automatically as protection against unexpected crashes and network outages.
For this, the implementation serializes the state and object-specific behavior of all morphs.
For each serialized state only the differences to the previously saved one is stored.
Further, the implementation uses client-side storage for fast access and to safeguard against outages of both the client-side and the server-side.
As only the differences to the last saved version is stored and previous versions, therefore, remain available, Offline Worlds could, conceivably, also be used to re-establish other versions than the latest, but does not provide support for this.

Offline Worlds preserves the latest state of a Lively Kernel world to support recovery from system failures, while our approach preserves multiple versions of the runtime to provide recovery when programmers make inappropriate changes.
Offline Worlds only preserves the state of all graphical objects.
In contrast, our system also recognizes changes to classes, globally accessible state, and morph state explicitly excluded from serialization.
Further, our approach saves versions incrementally and re-establishes versions dynamically, while Offline Worlds saves and loads versions of the world in discrete, interruptive steps.
That is, even when not used to recover from a system failure, Offline Worlds still requires to re-load the entire world, while our system only switches which versions of particular objects should be used and even preserves object identity of these through the version-aware references.


\subsection{Back-in-Time Debugging}

Back-in-time Debuggers~\cite{Lewis2003BIT}, also known as \emph{Omniscient Debuggers}, allow developers to inspect previous program states and step backwards in the control flow to undo the side effects of statements.
Approaches for this are either based on logging or replay: either the debugger records information to be able to recreate particular previous situations, requiring mainly space for the different states, or the debugger re-executes the program up to a particular previous situation, requiring mainly time to re-run the program.
While many logging-based approaches introduce significant execution overheads, replay-based approaches have to ensure that the program is re-executed deterministically, which can be a difficult problem when, for example, programs can rely on state outside of the program runtime such as the content of files or the state of other programs.

Our approach is more related to logging-based back-in-time debugging.
It allows re-establishing a previous state through preserving information.
However, back-in-time debuggers need to be able to undo the effects of each statement separately, while our system's versioning granularity is arbitrarily and can, for example, correspond to programmer interactions with the system.
In general, back-in-time debuggers support a particular development task---debugging---and, thus, are also often only active when a program is started in a separate debugging mode.
In contrast, the purpose of object versioning is more comprehensive.
We expect object versioning to be active at least during all development tasks, but possibly even be enabled at all times.


\subsection{Software Transactional Memory}

\ac{stm}~\cite{Shavit1995STM} captures changes to values in transactions, analogous to database transactions.
Each transaction has its own view of the memory, unaffected by other concurrently running transactions.
That is, multiple versions of the system state can coexist and which version is read and written to depends on the transaction.
Transactions contain a number of program statements that are executed atomically.
The changes from a transactions are only permanent when no conflicts occur with other transactions.
On conflicts, all changes from the transaction are rolled back and undone.

\ac{stm} and our approach are similar in that multiple versions of the system state can coexist and that a previous state can be re-established if necessary.
\ac{stm}, however, provides concurrency control and an alternative to lock-based synchronization, while our approach provides recovery support to developers when changes turn out be inappropriate.
\ac{stm} transactions are automatically rolled back when changes conflict with changes from other concurrently running transactions, while our versions are offered to programmers to undo changes when necessary.
That is, with our system programmers actively decide to undo changes when these, for example, negatively impact the functionality, design, or performance of programs. 
Our versions of the runtime are also first-class objects, which can be stored in variables and be re-established at any time, while transactions are always created implicitly through particular control structures and commited immediately upon success.



\section{Dynamically Scoping First-class Groups of Changes}

The approaches presented in this sections allow to combine changes into first-class objects and run code with particular sets of changes.


\subsection{Worlds}

Worlds are a language construct to capture side effects and control the scope of them: changes to the state of objects are by default only effective in the world in which the changes occurred.
Worlds are first-class values, to be used to execute statements in a particular world.
A new world can be spawned from an existing world, which establishes a child-parent relationships between the two worlds.
Developers can commit changes contained in a child world to its parent world, thereby extending the scope of the captured side effects.
For this, the Worlds approach further includes conditions to prevent inconsistencies as result of commits.

In comparison, Worlds provides a language construct to support explicitly experimenting with different states of the runtime, while object versioning allows to preserve versions of the entire runtime intented to be created implicitly and continuously: Our approach does not include extensions to the host programming languages and no conditions under which versions of the runtime should be merged into predecessor versions.

Other differences between Worlds and our approach are mainly on the implementation level.
Our implementation in JavaScript does not prevent garbage collection as Worlds does.
Further, both use different libraries for source transformations, which our choice does faster and without relying on JavaScript exceptions for backtracking.


\subsection{Object Graph Versioning}

Object Graph Versioning\cite{Pluquet2009ECP} allows access to previous states of objects.
With it, fields of objects can be marked as \emph{selected} fields.
When a snapshot is created, the values of these selected fields are preserved.
That is, not every state can be re-established, but states that are part of explicit global snapshots. 
The approach, thus, provides fine-grained control to programmers regarding which fields of which objects should be preserved when.

The implemenation of Object Graph Versioning is similar to our solution.
Analogous to our proxy-based version-aware references, selected fields refer not to their values directly, but to chained arrays that manage the multiple versions of a field and delegate access to the current version transparently.
Further, the chained arrays also decide which version to retrieve and when to create new versions using a global version identifier.
However, in constrast to our sulution, individual fields are versioned and only when programmers explicitly mark them as selected.

Object Graph Versioning aims to support the implementation of applications that require access to previous states of objects such as application-specific undo/redo or tools like back-in-time debuggers.
In contrast, our approach to object versioning aims to support recovery of entire system states when changes turn out inappropriate during the development of applications.

Reusing parts of Object Graph Versioning for our solution was not an option.
It was implemented in Smalltalk, while our implementation provides recovery support for the Lively Kernel, which is implemented in JavaScript.


\subsection{Context-oriented Programming}

Context-oriented Programming~\cite{Hirschfeld2008COP} adds dedicated language constructs for dynamic behavior adaptions.
Depending on context information, COP allows to enable and disable layers, which contain variations to be executed instead or around methods of object-oriented base programs, at runtime.
Context information can be any information which is computationally accessible.
Different implementation of COP provide different mechansims to scope the activation of layers: for example, layers can be activated explicitly for a particular scope of the program or globally for the entire runtime.
In ContextJS~\cite{Lincke2011OIC} it is even possible to activate layers only for specific objects.

In comparison to our approach, COP also allows to group changes to the system and which of those sets of changes are active can be changed dynamically.
However, while COP concentrates on behavior variations, our approach recognizes changes to both state and behavior.
COP supports the composition of multiple indepedent layers, while with object versioning runtime versions are related more permanently in ancestor relationships and only one version is active at a given point in time.
COP further aims on separating heterogeneous cross-cutting concerns, while the motivation of object versioning is supporting developers to recover previous development states.
However, \cite{Lincke2012SCS} showed that COP can also allow developers to experiment with changes to a system: developers may implement their proposed changes to behavior in layers, not to primarily at modularize context-dependent adaptions, but to not change the system permanently and instead be able to recover the original system easily.
This requires developers to make experiments explicitly though---explicitly creating layers and explicitly moving code from layers back to the base system once experiments are considered finished, at least when developers want to maintain the original modularization of the system.


\subsection{ChangeBoxes}

ChangeBoxes~\cite{Denker2007EEC} is an approach to capture and scope changes to a system in first-class entities, also called ChangeBoxes.
A ChangeBox can embody changes to multiple elements of a software system such as adding a field, removing a method, or renaming a class.
The approach does not constrain how changes get grouped into ChangeBoxes, but every change to the system has be encapsulated in a ChangeBox.
Each ChangeBox can be used for deriving the set of changes for the scope of a running process.
This way, multiple running processes can view the system differently by using different ChangeBoxes.
ChangeBoxes can have ancestor relationships and merge changes from multiple ancestors.
Using these ancestor relations, ChangeBoxes can be used to review the evolution of systems and to undo changes.

The ChangeBoxes approach is similar to our approach as changes to the system are grouped into versions and these can be used to run code in different versions of the runtime.
Further, both solutions are also comparable in that there is no definite notion in how exactly changes are to be grouped.
Our object versioning approach, however, is intended to be used to group changes associated with developer actions and a simple global undo/redo mechanism to undo inappropriate actions is built into our solution.
To actually undo changes ChangeBoxes, in contrast, is rather tedious~\cite{Steinert2012COE}.
Furthermore, ChangeBoxes recognizes only changes to the static elements of a software system such as packages, classes, methods, and fields, while object versioning allows to also version the state and behavior of objects.


\subsection{Practical Object-oriented Back-in-Time Debugging}

Practical Object-oriented Back-in-Time Debugging~\cite{Lienhard2008POB} is a logging-based approach to back-in-time debugging that uses alternative references to preserve the history of each object.
These alternative references, called Aliases, are actually objects, part of the application memory, and contain information about the history and origin of the values stored in objects.
Aliases are not passed around, but instead are created for each read or write of an object field or an array and for each reference passed as parameter.
Each of these aliases refers to an actual value, but also to another alias---its predecessor---representing the value previously stored by a field and to the alias that was used to create this new alias from---its origin.
An alias and its origin both refer to the same value, but provide different information as their creation context, which always is a particular method.
That is, the origin link can be used to follow the object's ``flow'' through the program.
Each alias also records a timestamp when created and with this information the predecessor link can be followed to read a value as it was at a particular moment in time.

In comparison, there is not just one alias object for every mutable object, but as many as there are references to that object, whereas there is always only one version-aware reference for every mutable object with our approach.
Further, an alias object has time-stamped predecessors for the values stored in a field, while our version-aware references hold versions of an object that correspond to particular discrete versions of the runtime.
That is, with the presented back-in-time debugging solution its possible to recreate all states the system was in and also retrace the flow of all values, while our system stores only particular meaningful versions that, for example, might correspond to developer actions.
Another difference lies in the expected usage extent: the alias references are intended to be used only for explicit debugging sessions, while our version-aware reference are intended to be used always.

