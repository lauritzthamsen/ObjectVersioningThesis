\chapter{Related Work} \label{chapter:RELATED_WORK}

Two categories of related work are presented in this chapter:

\begin{enumerate}
    \item Approaches related to our motivation and, thus, to providing previous versions of system state when there is a need for recovery.
    \item Approaches related to the technical solution presented in this thesis and, thus, to combining changes into first-class objects that can be scoped dynamically.
\end{enumerate}


\section{Recovery of Previous System States}

The approaches presented in this section support developers in recovering previous states without requiring developers to create snapshots of the systems beforehand.


\subsection{CoExist}

CoExist~\cite{Steinert2012COE} provides recovery support through continuous versioning in Squeak/Smalltalk.
For each change made to source code, CoExist creates a new version of the system sources, resulting automatically in a fine-grained history of changes.
CoExist then presents this history in a timeline and a browser.
For each version, those tools can show the changes, test results, and a screenshot.
Developers can easily recover previous development states, even without taking precautionary actions explicitly.
This way, developers can concentrate on implementing their ideas and let CoExist record versions for each change to be able to recover every version later-on.

Both CoExist and our object versioning record and manage multiple versions of the development state.
They have in common that preserved versions are also part of the program runtime and that versions can be re-established easily.
CoExist, however, recognizes only changes to the source code of classes, while our system also preserves the state and behavior of objects.
Currently, only CoExist records versions continuously on the granularity of changes made by developers and also provides much more tool support to find and recover changes from previous versions.


\subsection{Lively Kernel Offline Worlds}

Offline Worlds~\cite{Czuchra2012OfW} is an approach to protect the state of a Lively Kernel world against system failures by saving it periodically.
In a fixed time interval the world is saved automatically as protection against unexpected crashes as well as network or server outages.
For this, the implementation serializes the active Lively Kernel world.
Serializing a morphic World includes the state and object-specific behavior of all contained morphic applications, but does not include changes to the core system's source code.
The serialized world is diffed against the previously saved world and only the differences are stored.
Further, the implementation uses client-side storage for fast access and to be safeguarded against both outages of the client-side and the server-side.
As only the differences to the last saved version is stored and previous versions, therefore, remain available, Offline Worlds could, conceivably, also be used to re-establish other versions than the latest, but does not provide support for this usage.

The Offline Worlds approach aims at preserving the latest state of a the Lively Kernel world to provide recovery from system failures, while our approach aims to preserve multiple versions of the runtime to provide recovery from inappropriate changes.
Offline Worlds only preserves the state of all graphical objects.
In contrast, our versions can also contain other globally accessible state such as the global system configuration, classes, and state explicitly excluded on serialization.
Further, our approach saves new versions incrementally and resolves to different versions dynamically, while Offline Worlds saves and loads versions of the world in a discrete, interruptive step.
That is, when used to recover previous state deliberately not as reaction on system failure, Offline Worlds requires to re-load the entire world, while our system can switch out just the objects that changed and even preserves object identity through the version-aware references.
Our versioning is, however, no protection against system or network outages.


\subsection{Back-in-Time Debugging}

Back-in-time Debuggers~\cite{Lewis2003BIT}, also known as Omniscient Debuggers, allow developers to inspect previous program states and step backwards in the control flow to undo the effects of statements.
Approaches for this are either based on logging or replay: either the debugger records previous states to be able to recreate a particular previous situations, requiring mainly space for all the different states, or the debugger re-executes the program up to a particular previous situation, requiring mainly time to run the program again.
While many logging-based approaches introduce significant execution overheads, replay-based approaches have to ensure that the program is re-executed deterministically, which is a difficult problem as, for example, programs can rely on state outside of the program runtime such as file content or the state of other programs.

Our approach is more related to logging-based back-in-time debugging.
Both approaches allow to re-establish a previous situation through preserving state.
However, back-in-time debuggers need to be able to undo the effects of each statement separately, while our system's versioning granularity is arbitrarily and can, for example, correspond to developer interaction with the live system.
In general, back-in-time debuggers support a particular development task---debugging--- and, thus, are also often only active when a program is started in separate debugging mode, while the purpose of object versioning is more comprehensive and we expect it to be active at least during all development tasks, but possibly even be always enabled.


\subsection{Software Transactional Memory}

\ac{stm}~\cite{Shavit1995STM} allows to edit values in transactions, analogous to database transactions.
Each transaction has its own view of the memory, unaffected by other concurrently running transactions.
That is, multiple versions of the state of a system can coexist and which one is read and written to depends on the transaction.
Transactions contain a number of program statements to be executed as one atomic operation.
The changes from these statements are only permanent when no conflicts with other transactions occur.
On conflicts, however, all changes made in a transaction are rolled back and undone.

\ac{stm} and our approach are similar in that multiple versions of the system state can coexist and that a previous state can be re-established if necessary.
\ac{stm}, however, provides concurrency control and an alternative to lock-based synchronization, while our approach provides recovery support to developers when changes turn out be inappropriate.
That is, \ac{stm} transactions are automatically rolled back when changes conflict with changes from other concurrently running transactions, while our versions are offered to programmers to undo changes that negatively impact the functionality, design, or performance of programs. 
Our versions of the runtime are further first-class objects, which can be stored in variables and be re-established at any time, while transactions are always created through particular control structures and commited immediately upon success.



\section{Dynamically Scoping First-class Groups of Change}

The approaches presented in this sections allow to combine changes into first-class values and, subsequentely, to run code with a particular set of such groups.


\subsection{Worlds}

Worlds are a language construct to capture side-effects and control the scope of them: changes to the state of objects are by default only effective in the world in which the changes occurred.
Worlds are first-class values, to be used to execute statements in a particular world.
A new world can be spawned from an existing world, which establishes a child-parent relationships between the two worlds.
Developers can commit changes contained in a child world to its parent world, thereby extending the scope of the captured side-effects.
For this, the Worlds approach further includes conditions to prevent inconsistencies as result of commits.

In comparison, Worlds provides a language construct to support explicitly experimenting with different states of the runtime, while object versioning allows to preserve versions of the entire runtime intented to be created implicitly and continuously: Our approach does not include extensions to the host programming languages and no conditions under which versions of the runtime should be merged into predecessor versions.

Other differences between Worlds and our approach are mainly on the implementation level.
Our implementation in JavaScript does not prevent garbage collection as Worlds does.
Further, both use different libraries for source transformations, which our choice does faster and without relying on JavaScript exceptions for backtracking.

\subsection{Context-oriented Programming}

Context-oriented Programming~\cite{Hirschfeld2008COP} adds dedicated language constructs for dynamic behavior adaptions.
Depending on context information, COP allows to enable and disable layers, which contain variations to be executed instead or around methods of object-oriented base programs, at runtime.
Context information can be any information which is computationally accessible.
Different implementation of COP provide different mechansims to scope the activation of layers: for example, layers can be activated explicitly for a particular scope of the program or globally for the entire runtime.
In ContextJS~\cite{Lincke2011OIC} it is even possible to activate layers only for specific objects.

In comparison to our approach, COP also allows to group changes to the system and which of those sets of changes are active can be changed dynamically.
However, while COP concentrates on behavior variations, our approach recognizes changes to both state and behavior.
COP supports the composition of multiple indepedent layers, while with object versioning runtime versions are related more permanently in ancestor relationships and only one version is active at a given point in time.
COP further aims on separating heterogeneous cross-cutting concerns, while the motivation of object versioning is supporting developers to recover previous development states.
However, \cite{Lincke2012SCS} showed that COP can also allow developers to experiment with changes to a system: developers may implement their proposed changes to behavior in layers, not to primarily at modularize context-dependent adaptions, but to not change the system permanently and instead be able to recover the original system easily.
This requires developers to make experiments explicitly though---explicitly creating layers and explicitly moving code from layers back to the base system once experiments are considered finished, at least when developers want to maintain the original modularization of the system.


\subsection{ChangeBoxes}

ChangeBoxes~\cite{Denker2007EEC} is an approach to capture and scope changes to a system in first-class entities, also called ChangeBoxes.
A ChangeBox can embody changes to multiple elements of a software system such as adding a field, removing a method, or renaming a class.
The approach does not constrain how changes get grouped into ChangeBoxes, but every change to the system has be encapsulated in a ChangeBox.
Each ChangeBox can be used for deriving the set of changes for the scope of a running process.
This way, multiple running processes can view the system differently by using different ChangeBoxes.
ChangeBoxes can have ancestor relationships and merge changes from multiple ancestors.
Using these ancestor relations, ChangeBoxes can be used to review the evolution of systems and to undo changes.

The ChangeBoxes approach is similar to our approach as changes to the system are grouped into versions and these can be used to run code in different versions of the runtime.
Further, both solutions are also comparable in that there is no definite notion in how exactly changes are to be grouped.
Our object versioning approach, however, is intended to be used to group changes associated with developer actions and a simple global undo/redo mechanism to undo inappropriate actions is built into our solution.
To actually undo changes ChangeBoxes, in contrast, is rather tedious~\cite{Steinert2012COE}.
Furthermore, ChangeBoxes recognizes only changes to the static elements of a software system such as packages, classes, methods, and fields, while object versioning allows to also version the state and behavior of objects.


\subsubsection{Practical Object-oriented Back-in-Time Debugging}

Practical Object-oriented Back-in-Time Debugging~\cite{Lienhard2008POB} is a logging-based approach to back-in-time debugging that uses alternative references to preserve the history of each object.
These alternative references, called Aliases, are actually objects, part of the application memory, and contain information about the history and origin of the values stored in objects.
Aliases are not passed around, but instead are created for each read or write of an object field or an array and for each reference passed as parameter.
Each of these aliases refers to an actual value, but also to another alias---its predecessor---representing the value previously stored by a field and to the alias that was used to create this new alias from---its origin.
An alias and its origin both refer to the same value, but provide different information as their creation context, which always is a particular method.
That is, the origin link can be used to follow the object's ``flow'' through the program.
Each alias also records a timestamp when created and with this information the predecessor link can be followed to read a value as it was at a particular moment in time.

In comparison, there is not just one alias object for every mutable object, but as many as there are references to that object, whereas there is always only one version-aware reference for every mutable object with our approach.
Further, an alias object has time-stamped predecessors for the values stored in a field, while our version-aware references hold versions of an object that correspond to particular discrete versions of the runtime.
That is, with the presented back-in-time debugging solution its possible to recreate all states the system was in and also retrace the flow of all values, while our system stores only particular meaningful versions that, for example, might correspond to developer actions.
Another difference lies in the expected usage extent: the alias references are intended to be used only for explicit debugging sessions, while our version-aware reference are intended to be used always.

