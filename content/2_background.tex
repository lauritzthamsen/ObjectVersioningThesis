\chapter{Background} \label{chapter:BACKGROUND}

This chapter describes prototype-based programming, the Lively Kernel, and CoExist.
These works are the background of this thesis as it introduces an approach towards CoExist-like recovery support in prototype-based programming systems, which we implemented for the Lively Kernel.

\section{Prototype-based Programming}

Prototype-based programming is object-oriented programming in which applications are created directly with objects, without requiring developers to define classes first.
Examples for general-purpose programming languages that implement prototype-based programming are Self, JavaScript, and Kevo~\cite{Taivalsaari1992Kevo}.
Many end-user programming systems such as Scratch~\cite{Maloney2010SPL}, Etoys~\cite{Kay2005Etoys} and Fabrik~\cite{Ingalls1988FVP}, and Lively Fabrik~\cite{Lincke2009LFW} also enable users to express their programs through objects.

\paragraph{Similar Objects Without Classes}
Self and JavaScript incorporate prototypical inheritance.
They allow objects to inherit state and behavior directly from other objects through delegation: an object has a prototype to which it delegates when looking up a property in the object itself yields no results.
In Self, objects are created by cloning other objects and, this, operation also sets the prototype: The clone's prototype is the original object.
In JavaScript, objects are created from constructor functions and the functions determine the prototypes of objects.
Kevo, in constrast, does not provide prototypical inheritance.
In Kevo, programmers can only make full copies of objects.
That is, programmers can create new objects with initially the same state and behavior as existing objects, but all objects remain self-contained.
That is, in Kevo, changing an object only changes that particular object and a particular object can only be changed by directly changing it, not by changing any other artifact.
To adapt many objects at once, programmers can only use so-called \emph{module operations} that are evaluated for a group of objects. 

Despite this difference in whether properties can be shared among objects and how, therefore, families of objects can be affected, prototype-based programming always allows to build programs from particular objects.
This is the fundamental difference to the class-based style of object-oriented programming, in which programs are expressed with more abstract definitions of structure and behavior.
In prototype-based programming, the parts of a program are objects with particular state.
All parts are specific examples rather than general categories.

There are different advantages associated with this kind of programming:
\begin{itemize}
    \item \cite{Taivalsaari1996CVP} and \cite{Ungar1987SPS} suggest that it might be easier for programmers to understand concrete examples than to grasp abstract classes. A concrete example provides particular values for its state and, in case of objects with a visual appearance, can be actually looked at.
    \item \cite{Ungar1987SPS} and \cite{Borning1986CVP} describe how prototype-based programming makes it easier to introduce one-of-a-kind objects with their own structure or behavior.
    \item \cite{Borning1986CVP} and \cite{Maloney1995Mor} argue that especially editing visual objects can be more concrete with prototypes. Instead of writing code that describes the appearance of objects, programmers can manipulate visual objects directly. Programmers could, for example, use the mouse to manipulate properties like the size, position, or to combine multiple elements. This way, programmers always see intermediate states instead of only receiving feedback on explicit test runs in-between edit-compile-load cycles. 
\end{itemize}

\paragraph{Editing Objects at Runtime}
Many prototype-based programming systems, including all the examples given in this section, allow to manipulate objects at runtime.
Scratch, Etoys, Fabrik, Lively Fabrik, the Lively kernel, and Self also all provide tools dedicated to manipulating graphical objects directly.
Such graphical objects range from basic objects like primitive shapes to complete applications like presentation software or programming tools.
Prototype-based programming, programming at runtime, and direct manipulation of graphical objects seem to be properties that suit each other.


\section{The Lively Kernel}

The Lively Kernel is a programming system in the tradition of Smalltalk and Self.
Development in the Lively Kernel happens at runtime.
It incorporates tools and techniques to be completely self-sufficient.
Thus, programmers can create versions of the Lively Kernel with the Lively Kernel.

The Lively Kernel is also a browser-based system.
It is implemented in JavaScript and renders to HTML.

\subsubsection{Programming with Prototypes and Classes}

As the Lively Kernel is based in JavaScript, the system and applications are expressed in a prototype-based object-oriented language that provides prototypical inheritance.
At the same time, the Lively Kernel also provides a class system and considerable parts of the system are expressed using classes.

One of the system parts expressed through classes is an implementation of Morphic~\cite{Maloney1995Mor}, a framework for developing graphical applications.
Programmers can alter graphical objects of this framework, which are called \emph{Morphs}, using direct manipulation and through a number of dedicated tools.
That is, the Morphic framework itself is implemented using classes, morphs are an example of objects that are often edited directly and not through adapting existing or creating new classes.
Each morph has a class but can also have object-specific behavior.
Further, morphs can be created both through instantiating a Morphic class and through copying an existing morph.
This way, the Lively Kernel mixes the class-based with the prototype-based style of object-oriented programming.

The Lively Kernel's copy operation does not establish a prototypical inheritance relationship between the copy and the original.
Instead it creates a full copy of the original morph's properties, including its class.
Therefore, even though JavaScript incorporates prototypical inheritance, the Lively Kernel encourages programmers to use classes to share behavior among objects.

\subsubsection{Direct Manipulation of Morphs}

Programmers can change the position of morphs by \emph{dragging} and the composition by an alternative dragging, called \emph{grabbing}.
The composition of morphs is also part of Morphic and a morph can have submorphs.
This way, morphs are not limited to to be basic shapes or simple widgets, but can be entire user interfaces of arbitrary applications.

The Lively Kernel provides a set of manipulation tools, called \emph{Halos}, as shown in Figure~\ref{fig:Halos}, that developers can bring up for each morph.
The different halo buttons allow, for example, to resize, rotate, and copy morphs.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.3\textwidth]{figures/2_background/1_halos.pdf}
    \caption{The halo buttons of a basic morph.}
    \label{fig:Halos}
\end{figure}

Other halo buttons open specific tools, which are shown in Figure~\ref{fig:LivelyTools}:

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{figures/2_background/2_LivelyTools.pdf}
    \caption{Three Lively Kernel's tools to manipulate morphs: the Inspector, the Style Editor, and the Object Editor.}
    \label{fig:LivelyTools}
\end{figure}

\begin{enumerate}
    \item The \emph{Inspector}~\circnum{1} presents all the values that make up a morph's current state. It also has a small code pane at the bottom that can be used to manipulate the properties programmatically.
    \item The \emph{Style Editor}~\circnum{2} allows to manipulate certain aspects of a morph's visual appearance. Programmers can use it to change, for example, a morphs color, border width, or the layout of its submorphs.
    \item The \emph{Object Editor}~\circnum{3} is a tool to edit the object-specific behavior of morphs. It shows all scripts of a particular morph and allows programmers to add, remove and edit scripts.
\end{enumerate}


\subsubsection{Saving Morphs to the Shared Parts Bin Repository}

A related tool is the Lively Kernel's \emph{Parts Bin}~\cite{Lincke2012LPC}, an object repository to commit and load specific versions of morphs.
Morphs saved to the Parts Bin are called \emph{parts} to emphasize the ability to reuse any of the morphs in the Parts Bin for other morphic applications.
Figure~\ref{fig:PartsBin} shows the Parts Bin, opened on the \emph{Tools} category, which includes both the Style Editor and the Object Editor.
Both these tools are examples for graphical applications developed from available parts.
Their functionality is expressed in scripts and they are available to users through the Parts Bin.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\textwidth]{figures/2_background/3_partsBin.pdf}
    \caption{The Lively Kernel's Parts Bin opened on the \emph{Tools} category.}
    \label{fig:PartsBin}
\end{figure}

The root of the scenegraph of visible morphs is called \emph{World}.
Worlds are not shared via the Parts Bin, but can be saved as a Web pages.
A world stores the state of all visible morphs when saved and that state can be reloaded with the world.


\section{CoExist}

CoExist\footnote{\url{http://www.bastiansteinert.org/coexist.html}, accessed February 28, 2014} supports programmers through automatic and continuous versioning.
CoExist preserves access to each intermediate development state.
The states are recorded as separate version in their original order. 
For each version CoExist provides access to diffs, test results, and screenshots of the development environment.
Programmers can review their programming sessions, inspect the impact each individual change had on test cases, and recover information from previous development states.
They can withdraw changes completely or only re-visit a previous state to recover partial information as, for example, the source code for a specific method.

\subsubsection{Tools to Recover Previous Development States}

CoExist provides two tools to help programmers benefit from the preserved development histories, shown in Figure~\ref{fig:CoExist}:

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{figures/2_background/4_coexistTools.pdf}
    \caption{CoExist's tools to manage the preserved development states: the \emph{Timeline} and the \emph{Version Browser}.}
    \label{fig:CoExist}
\end{figure}

\paragraph{Timeline}
CoExist's \emph{Timeline} tool is located at the bottom of the development environment.
It shows each intermediate version with a small rectangle that indicates the impact on test cases: the bottom of the rectangle shows how many test cases passed and failed absolutely, while the top highlights only test results affected by the changes made for this particular version.
Hovering above such a version rectangle indicates what exactly changed in terms of methods and classes.
Clicking a version provides access to its source code and more information on test results, but also allows to re-establish the version.

\paragraph{Version Browser}
Besides the timeline of versions, a \emph{Version Browser} tool shows changes in a different layout.
For each package it shows the changes made in that package.
It presents the same information on test cases, but also includes a diff view.
Moreover, it provides a screenshot for each version that shows how the development environment looked like when the version was created.

\emph{In summary}, the tools support programmers in re-tracing their steps, understanding the impact of their actions, and in recovering information from previous development states.


\subsubsection{Benefits of Continuous Versioning}

CoExist is intented to reduce the effort that programmers put into recovery and, thereby, to encourage programmers to explore their ideas through making changes to the code.

Without CoExist, either compensational or precautionary actions are necessary for recovery.
When programmers unintentionally introduce errors, decrease performance, or harm the program design, they have to repair changed code.
They either need to edit the code again or load a previously commited version of the code.
Editing code of potentially many methods across and many classes is obviously a significant effort and error-prone.
Loading a previous version is, however, only possible if a version had been commited previously.
That is, programmers can reduce the cost of recovery by anticipating recovery needs beforehand.
Preserving versions is, however, also an effort and especially so when revision histories are expected to be well-documented and immediately useful.
For that, programmers need to assemble changes to meaningful increments, test these, and write helpful commit messages.
% Testing each one directly is also advocated as it can help to find introduced problems directly intead of later analyzing long lists of changes that all could potentially have introduced a problem.

CoExist's approach to recovery is in contrast easy, and fast.
Developers do not have to take these explicit precautionary actions, but are still able to undo changes when necessary.
In this regard, CoExist is similar to undo/redo systems.
CoExist however provides access to the previous development states of entire systems, not just the code of particular source code files.
Moreover, it presents preserved versions more structured.
Each version is associated with the static structure of the software system, related to other versions in a timeline, and accompanied by test results.
Additionally, making changes to a previous state in CoExist does not overwrite the history, but creates a branch.

\emph{In essence}, instead of worrying about negative consequences, programmers can focus on implementing their ideas and rely on CoExist to help in case any action unexpectedly needs to be undone.
