\chapter{Background} \label{chapter:BACKGROUND}

\todo{a couple of statements that preview the main points of each of the following subsections}


\section{Prototype-based Object-oriented Programming}

languages in which developers implement systems directly with objects, not classes: Self, JavaScript, Kevo~\cite{Tailvalsaari1992Kevo}..
prototypical inheritance or full copies / concatenation
% In these systems programmers design the behavior of single objects, without adaptin classes or other forms of abstract source code descriptions. 


development at runtime
some of these languages are used in systems in which programmers develop at runtime, like in Smalltalk: Self, Kevo, the Lively Kernel, Fabrik~\cite{Ingalls1988FVP}, Scratch\cite{Maloney2010SPL}, Etoys~\cite{Kay2005Etoys}
some of these systems are self-supporting like Self and the Lively Kernel, while others only allow to develop particular objects in this fashion like Scratch and Etoys.

% Examples for objects developed in this approach range from relatively simple objects like primitive graphical shapes over interactive widgets to more applications that are more directly useful like presentation software or programming tools.


There are different advantages associated with this kind of development.
First, it is easier to introduce unique objects with their own specific structure or behavior~\todo{cite: ungar-simplicity or borning here}. 
Second, developers may benefit from seeing concrete examples before reading the abstract class description~\todo{cite: tailvalsaari-cvp}.
A concrete example provides particular values for its states and, in case of objects with a visual appearance, can be actually looked at.
Third, especially for such visual objects, development systems can provide more direct manipulation tools with more immediate feedback on each change.
Such direct manipulation can take the form of drag-and-drop operations to manipulate graphical composition, manipulation of visual properties like color fills and rotations, or evaluating a code snippet that effects the object visibly.


\section{The Lively Kernel}

Lively, also referred to as the Lively Kernel, is a browser-based programming system in the tradition of both Smalltalk and Self.
It incorporates tools and techniques to be completely self-sufficient.
Development in Lively happens at runtime, and programmers can create and save new version of the Lively Kernel itself.

Lively is based in the JavaScript programming language.
Therefore, the system and applications are expressed in a prototype-based object-oriented language that also provides prototypical inheritance.
At the same time, Lively also provides a class system for JavaScript and considerable parts of the system itself are expressed using classes.
One of these parts expressed through classes is an implementation of Morphic~\cite{Maloney1995Mor}, a framework for developing graphical applications.
Programmers can alter graphical objects of this framework, which are called \emph{Morphs}, using direct manipulation and through a number of tools.

Programmers can change the position of morph objects by dragging and the composition by an alternative dragging, which is called \emph{grabbing}.
Further, Lively provides a set of tools, called \emph{Halos}, directly at morphs, as shown in Figure \todo{halo figure}.
The different halo buttons allow, for example, to resize, rotate, and copy morphs, while other halo buttons open specific tools, which are shown in Figure~\todo{figure for the inspector, the style editor, and the object editor} to further manipulate the morphs:

\begin{itemize}
    \item The \emph{Inspector} presents all the values that make up a morph's state. It also has a small code pane at the bottom, intended to be used to manipulate the state programmatically.
    \item The \emph{Style Editor} allows to manipulate certain aspects of a morph's visual appearance. Programmers can use it to, for example, change a morphs color, border width, or the layout of its submorphs.
    \item The \emph{Object Editor} is a tool dedicated to the object-specific behavior of morphs, which are called \emph{scripts} in Lively. It shows all scripts of a particular morph, but also can add and adapt scripts to that.
\end{itemize}

Another tool related to morphs, though not available from a halo button, is Lively's \emph{Parts Bin}~\cite{Lincke2012LPC}, an object repository to save and load specific versions of morphs.
Morphs saved to the Parts Bin are called \emph{parts} to emphasize the ability to reuse any one of the morphic implementations stored in the Parts Bin in another application.

When morphs are copied, Lively does not establish a prototypical inheritance relationship between the copy and the original.
Instead, Lively copies the entire state and both are instances of the same morphic class.

\todo{some screenshot that shows the tools, with numbers to show multiple distinct tools in a single screenshot..}

% In the case of Lively, developers can manipulate both abstract behavior descriptions and specific objects.
% They can make changes to source code in modules and classes, but also to the state and behavior of particular objects.
% Since classes and other abstract definitions are also edited at runtime, changes to both single objects and general classes take effect immediately, but developers still have a concrete example when editing objects to see their effects more clearly.
% For this direct manipulation, Lively's tools do focus on graphical objects, which are called \emph{Morphs} or \emph{Parts} in Lively.
% Morphs as Lively implements the Morphic framework~\cite{Maloney1995Mor}.
% Parts because developers can save versions of their objects in an object repository, called Parts Bin~\cite{}, which contains numerous simple simple parts to be used for more complete applications.
% Developers can use \emph{Halo} buttons to manipulate, for example, the size, position, or rotation of morphs, and further add one morph to another.
% They can change even more aspects of the appearance using a style editor, which allows to, for example, add borders to morphs or make their color more transparent.
% These two tools manipulate the state of particular objects directly.
% In contrast, a tool called Object Editor can be used to change all object-specific behavior of an object.
% Developers can view, change, save, and evaluate all scripts particular to that object.




\section{CoExist}

% In contrast to having developers manually preserve particular versions of their code and run the appropriate set of test cases for such, CoExist provides automatic recovery support.
% Every change made to source code yields a version for which CoExist also captures test results and a screenshot of the development state.
% Thus, developers have access to a fine-grained and rich history of development states when they need to recover previous situations.
% 
% CoExist allows developers to recover previous versions of the code without having to take precautionary actions manually.
% For each of those versions CoExists then automatically also captures test results and screenshots of the development environment, helping developers in finding relevant versions when recovery is necessary.
% 
% % Developers do not have to manually create commits or run tests for development states that seem important.
% 
% % sometimes easier to make the changes and experience the results than to anticipate the changes beforehand...)… 
% automatic and continuous versioning of the system code whenever code changes, whenever a user interacts/saves/changes code.
% allows to concentrate on implementing ideas… while a fine-grained versioning history, which can also be enriched with test results and screenshots to support finding relevant versions, is there for every change that turns out inappropriate.. programmers can always just make changes and concentrate fully on implementing them without too much thought and effort going into precautionary actions… because the coexist tool / tool support records all changes and their effect on test case outcomes… 



% This is supposed to reduce both the time spent on and the errors made in manually precautionary actions.
% Without CoExist, developers explicitly save explicit versions of the code and write short summaries, often in form of commit messages.
% Developers also run tests to understand the impact of their changes.
% While running all tests of the system can take a long time, deciding which takes are helpful in evaluating the recent changes also is often a difficult decision.
% As those two tasks are, thus, cumbersome, developers often do not do both for every single change, but aim to save interesting versions, creating a new version for every meaningful increment.
% However, estimating which changes might be risky and, thus, 
% 
% planning and deciding which groups of changes also pose an effort to developers, who need to estimate which 

% motivation for CoExist: explicit precautionary actions like saving versions is laborious and/or error-prone. saving each intermediate version is not practical (writing up some version comment, running all necessary tests, in the case of lively saving all objects takes a moment, often also no distinction between a private temporary snapshot and a meaningful increment that’s to be published and shared), while saving particular important versions is error-prone (not clear which version to save, risk assessment very difficult… reasons for recovery needs mostly unanticipated… recovery often necessary because of a mistake, because something wasn’t considered or anticipated… this risk assessment whether a change will be an actual increment is difficult… 

