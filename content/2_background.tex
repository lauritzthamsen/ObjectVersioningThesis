\chapter{Background} \label{chapter:BACKGROUND}

\todo{a couple of statements that preview the main points of each of the following subsections}


\section{Prototype-based Object-oriented Programming}

languages in which developers implement systems directly with objects, not classes: Self, JavaScript, Kevo~\cite{Tailvalsaari1992Kevo}..
prototypical inheritance or full copies / concatenation
% In these systems programmers design the behavior of single objects, without adaptin classes or other forms of abstract source code descriptions. 


development at runtime
some of these languages are used in systems in which programmers develop at runtime, like in Smalltalk: Self, Kevo, the Lively Kernel, Fabrik~\cite{Ingalls1988FVP}, Scratch\cite{Maloney2010SPL}, Etoys~\cite{Kay2005Etoys}
some of these systems are self-supporting like Self and the Lively Kernel, while others only allow to develop particular objects in this fashion like Scratch and Etoys.

% Examples for objects developed in this approach range from relatively simple objects like primitive graphical shapes over interactive widgets to more applications that are more directly useful like presentation software or programming tools.


There are different advantages associated with this kind of development.
First, it is easier to introduce unique objects with their own specific structure or behavior~\todo{cite: ungar-simplicity or borning here}. 
Second, developers may benefit from seeing concrete examples before reading the abstract class description~\todo{cite: tailvalsaari-cvp}.
A concrete example provides particular values for its states and, in case of objects with a visual appearance, can be actually looked at.
Third, especially for such visual objects, development systems can provide more direct manipulation tools with more immediate feedback on each change.
Such direct manipulation can take the form of drag-and-drop operations to manipulate graphical composition, manipulation of visual properties like color fills and rotations, or evaluating a code snippet that effects the object visibly.


\section{The Lively Kernel}

lively: self-supporting, web-based development environent, in the tradition of smalltalk~\cite{GoldbergRobson83} and self~\cite{Ungar1987SPS,Ungar2007SEL}, development at runtime.

morphic, morphs. the world. world can be saved and loaded, with all graphical versions saved with their current state.

in and for JavaScript: prototype-based programming language with prototypical inheritance.
so, programs can be expressed using objects and prototypical inheritance.

but also provides classes, layers, and traits. 

and provides a particular way of scripting graphical objects, called parts.
instances of classes, but can have instance-specific behavior, can be manipulated directly with various tools (inspector, object editor, halo buttons, style editor).
graphical objects developed in this fashion are called parts and can be saved to and loaded from an object repository, called the Parts Bin.
the Parts Bin also preserves versions of parts.
new parts can be created by instantiating classes and by copying existing parts, including loading versions of parts.

\todo{some screenshot that shows the tools, with numbers to show multiple distinct tools in a single screenshot..}

% In the case of Lively, developers can manipulate both abstract behavior descriptions and specific objects.
% They can make changes to source code in modules and classes, but also to the state and behavior of particular objects.
% Since classes and other abstract definitions are also edited at runtime, changes to both single objects and general classes take effect immediately, but developers still have a concrete example when editing objects to see their effects more clearly.
% For this direct manipulation, Lively's tools do focus on graphical objects, which are called \emph{Morphs} or \emph{Parts} in Lively.
% Morphs as Lively implements the Morphic framework~\cite{Maloney1995Mor}.
% Parts because developers can save versions of their objects in an object repository, called Parts Bin~\cite{Lincke2012LPC}, which contains numerous simple simple parts to be used for more complete applications.
% Developers can use \emph{Halo} buttons to manipulate, for example, the size, position, or rotation of morphs, and further add one morph to another.
% They can change even more aspects of the appearance using a style editor, which allows to, for example, add borders to morphs or make their color more transparent.
% These two tools manipulate the state of particular objects directly.
% In contrast, a tool called Object Editor can be used to change all object-specific behavior of an object.
% Developers can view, change, save, and evaluate all scripts particular to that object.




\section{CoExist}

% In contrast to having developers manually preserve particular versions of their code and run the appropriate set of test cases for such, CoExist provides automatic recovery support.
% Every change made to source code yields a version for which CoExist also captures test results and a screenshot of the development state.
% Thus, developers have access to a fine-grained and rich history of development states when they need to recover previous situations.
% 
% CoExist allows developers to recover previous versions of the code without having to take precautionary actions manually.
% For each of those versions CoExists then automatically also captures test results and screenshots of the development environment, helping developers in finding relevant versions when recovery is necessary.
% 
% % Developers do not have to manually create commits or run tests for development states that seem important.
% 
% % sometimes easier to make the changes and experience the results than to anticipate the changes beforehand...)… 
% automatic and continuous versioning of the system code whenever code changes, whenever a user interacts/saves/changes code.
% allows to concentrate on implementing ideas… while a fine-grained versioning history, which can also be enriched with test results and screenshots to support finding relevant versions, is there for every change that turns out inappropriate.. programmers can always just make changes and concentrate fully on implementing them without too much thought and effort going into precautionary actions… because the coexist tool / tool support records all changes and their effect on test case outcomes… 



% This is supposed to reduce both the time spent on and the errors made in manually precautionary actions.
% Without CoExist, developers explicitly save explicit versions of the code and write short summaries, often in form of commit messages.
% Developers also run tests to understand the impact of their changes.
% While running all tests of the system can take a long time, deciding which takes are helpful in evaluating the recent changes also is often a difficult decision.
% As those two tasks are, thus, cumbersome, developers often do not do both for every single change, but aim to save interesting versions, creating a new version for every meaningful increment.
% However, estimating which changes might be risky and, thus, 
% 
% planning and deciding which groups of changes also pose an effort to developers, who need to estimate which 

% motivation for CoExist: explicit precautionary actions like saving versions is laborious and/or error-prone. saving each intermediate version is not practical (writing up some version comment, running all necessary tests, in the case of lively saving all objects takes a moment, often also no distinction between a private temporary snapshot and a meaningful increment that’s to be published and shared), while saving particular important versions is error-prone (not clear which version to save, risk assessment very difficult… reasons for recovery needs mostly unanticipated… recovery often necessary because of a mistake, because something wasn’t considered or anticipated… this risk assessment whether a change will be an actual increment is difficult… 

