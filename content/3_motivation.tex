\chapter{Motivation} \label{chapter:MOTIVATION}

In the Lively Kernel, programmers can create applications by manipulating and composing graphical parts.
The development of such parts and related recovery needs are shown by example in this chapter.

\section{Part Development By Example}

To exemplify how developers change objects directly in Lively, we will outline the process of adding a new feature to Lively's Object Editor.

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{figures/3_motivation/1_magnifierButton.png}
    \caption{The Object Editor with its magnifier button highlighted with a red outline.}
    \label{fig:MagnifierButton}
\end{figure}

The new feature we add in this example is a magnifier button that can show the editor's current target.
The target is the object to which the Object Editor currently presents scripts to and allows to manipulate.
This requires to create and add a new button morph to the editor, shown in Figure~\ref{fig:MagnifierButton}.

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{figures/3_motivation/2_magnifierBehavior.png}
    \caption{Hovering a button of the Object Editor highlights the editor's current target.}
    \label{fig:MagnifierBehavior}
\end{figure}

The magnifier button implements two features: First, when a programmer hovers over the button, the Object Editor's current target object is highlighted through a blue and transparent overlay. Second, when a programmer clicks the button, the current target selection is revoked and the programmer can visually select the new target of the editor.
This example covers the first of these two behaviors.
Figure~\ref{fig:MagnifierBehavior} shows the behavior for an Object Editor currently targeting the character of a game.

The editor itself has been been developed by composing and editing graphical objects directly.
For this reason, we do not have to adapt any source code modules to change the editor, but rather manipulate and save the concrete object the editor is.

\paragraph{Manipulating the Button Morph}
First, we manipulate the visual appearance of a button, as shown in Figure~\ref{fig:ButtonBuilding}.
The button in \textcircled{1} can be found in the Lively Kernel's Parts Bin repository.
We then can use the button's halos and, in particular, the resize tool in \textcircled{2} to give the button a smaller and square extent.
Next, we can load an image showing a magnifier.
Using drag and drop we can add the image to the button and the button to the editor, as done in \textcircled{3}.
Dropping a morph onto another structurely connects morphs in Lively.
That is, moving the editor around will also move the button with its image accordingly, while saving will respectively include both the button and the image.
Subsequentely, we can add the result of these direct manipulations, visible in \textcircled{4}, to the object editor.

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{figures/3_motivation/3_buildingTheButton.png}
    \caption{Directly manipulating a button morph.}
    \label{fig:ButtonBuilding}
\end{figure}

All these changes are made directly to the state of objects: the button morph, the magnifier image morph, and the editor morph.
When programmers edit parts directly in this way, they often see the effects of their actions immediately.
For example, when adding the button morph to the Object Editor, where the button will be added is visible at all times.
Developers do not need to run any code to check the resulting appearance.

\paragraph{Scripting the Button Morph}
Next, the magnifier button needs its behavior.
We add scripts to the button to lay a translucent rectangle over the current target.
A naive implementation of this could include the following: the button holds a transparent rectangle, which is resized and added to the submorphs of the target the mouse enters the button, while it is removed from the scenegraph of visible objects when the mouse leaves the button.
The behavior is triggered from two specific scripts of the button morph: \lstinline{onMouseMove} and \lstinline{onMouseOut}.
These two scripts make sure that the overlay is shown only when the cursor hovers above the button.

Such scripts can be added using another Object Editor.
The editor also allows to evaluate code in the context of its target.
So, when developers want to test a script or even just specific lines of code, they can often try the behavior directly with the actual target.


\section{Recovery Needs When Developing Parts}

While manipulating objects directly, developers might make changes that they subsequentely want to undo.

In the previous example developers could, for example, make any of the following mistakes that all affect the development state:

\begin{itemize}
    \item accidentally grap and move a morph such as the new button and, thereby, change the carefully arranged layout.
    \item close a morph such as the Object Editor, which contains the new button, and, thus, lose meaningful unsaved changes.
    \item introduce an an error or a decrease in performance with an edit to a script.
\end{itemize}

Besides these accidental mistakes, well-intentioned changes can also turn out to be inappropriate.
When fine-tuning the visual appearance of a morph, for example, a developer might make many changes to the sizes, the positions, and the colors of morphs, only to decide later that a particular intermediate version was most appealing.
Developers can also change objects through a code snippet from a temporary workspace.
Such a snippet could of course change any number of properties of many objects at once, so re-establishing a previous situation would be a laborious task.

Another category of development interactions that potentially introduce undesirable changes is the exploration of code snippets.
The Object Editor always manipulates the scripts of a specific object and developers can evaluate code directly for that target object.
While such evaluation might help to understand the effects of particular code, it might also change the state of objects permanently.

For example, a programmer could edit the button's \lstinline{onMouseMove} script and afterwards could try a few lines of code to quickly evaluate his changes.
These lines, as shown in Figure~\ref{fig:onMouseOverScript}, would, however, add the rectangle to the current target, without regard to the conditions usually checked before and without setting the state as done right after the selection in the script.
Thus, while evaluating this selection allows to test the highlighting behavior, it leaves the system in a different state that it is not itended to be in through the script.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\textwidth]{figures/3_motivation/4_workspaceDoIt.png}
    \caption{The button's \lstinline{onMouseMove} script with a text selection.}
    \label{fig:onMouseOverScript}
\end{figure}

The given examples show that there are many situations in which developers might want to undo some of their operations.
In programming systems like the Lively Kernel, where programmers often work at runtime on objects, the development state consists of the state of objects.
Changes are always made to objects as even classes and modules are objects in the Lively Kernel.
More precisely, changes are always made to the \emph{state of objects} as even functions are also just properties of objects.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\textwidth]{figures/3_motivation/5_stateChanges.png}
    \caption{Adding a submorph changes the state of a morph.}
    \label{fig:changedCharacter}
\end{figure}

If, for example, the text selection in Figure~\ref{fig:onMouseOverScript} gets evaluated while the Object Editor targets the character, the character object is changed.
In particular, its collection of submorphs is altered.
Instead of having no submorphs, the character now has one submorph, as shown in Figure~\ref{fig:changedCharacter}.

To undo the change and re-establish the previous version of the character, the character object needs to have its previous state.
It needs to have an empty array again as its \lstinline{submorphs} property again.

Similarly, when the state of objects is preserved and can be re-established on demand, previous development states can be recovered whenever recovery is necessary.