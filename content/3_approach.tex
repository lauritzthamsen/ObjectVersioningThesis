\chapter{Object Versioning} \label{sec:APPROACH}

As explained in Section~\ref{sec:BACKGROUND}, programmers benefit from being able to recover previous development states without explicitly preparing for potential recovery needs.
We propose fine-grained object versioning for such recovery support in systems in which developers manipulate objects directly.
The programming system should preserve multiple versions of objects and should implement alternative references that transparently resolve to one of those versions.

Our approach for implementing this for the Lively Kernel in JavaScript relies on proxies and source transformations.
This provides a language-level solution for alternative references and object versioning.

\section{Version-aware References}

When changes made directly to objects turn out to be inappropriate, developers might want to re-establish a previous state of the programming system.
For this, we propose to save versions of objects and to use alternative, version-aware references.
Version-aware references dynamically resolve to one of several versions of objects.
To change which version of an object is used, no object state and no references need to be updated explicitly.
Instead the version-aware reference to the object in question resolves to the correct version dynamically when used, thereby encapsulating the multiplicity of versions per object.
Other than that, version-aware references behave like usual references.
They can be assigned to variables and be passed around.
A version of an object is in the simplest case a copy with its values for primitive values and object relations.
That is, version-aware references point to one out of many versions for a conceptually identical object, while objects are versioned in their entirety and not per property.
In particular, different versions might hold different version-aware references in the same instance variable or slot.
This also means versions of objects are also just objects in the programming runtime.

In the example shown by Figure~\ref{fig:EmployeeAddresses}, there are multiple versions for the \emph{address} property of an \emph{employee} object.
The reference stored for the address of the employee is aware of those versions.
When resolved, it chooses a particular version transparently, using some criteria to decide which version is currently supposed to be accessed, and returns that particular version.

\todo{figure 3.1: an object has a reference to multiple versions for the same object}

% \begin{figure}[h]
%     \centering
%     \includegraphics[width=\textwidth]{figures/EmployeeAddresses.png}
%     \caption{An object for an employee with different versions of his address.}
%     \label{fig:EmployeeAddresses}
% \end{figure}


Versions of objects are created and resolved coordinately to be able to resolve entire object graphs as they were at a particular moment.
For this, versions of objects created at the same time need to be relatable.
For example, annotating the versions of different objects that were created together with the same version information would allow to resolve all involved version-aware references to the versions of one runtime state.

Expanding our example, the address object might also hold version-aware references, while the employee object might be a particular version among many.
Figure Z2 shows a concrete and more comprehensive situation...
Mutiple versions for each object in this graph have been preserved together, each of those related versions of objects associated with the same version information, in this example named \emph{v1}, \emph{v2}, and \emph{v3}.
That is, when the \emph{company} object was preserved at the moment \emph{v1}, the \emph{person} object  was also like preserved in version v1.
Starting at object P now, we can resolve all object relations following the v1 annotations, thereby resolving the entire object graph as it was in version v1.

\todo{figure 3.2: an object graph with multiple version-aware references, showing relatable versions for different objects.. to be resolved to particular versions of the object graph together}

This way, when version-aware references are used consistently for all object relations in a programming runtime, the state of the entire runtime can be reset to particular versions.
However, this also only entails the programming runtime, while side effects to the state of other programs, for example server processes, or to databases cannot be reversed with this approach.

In addition, version-aware references should be transparent to programmers.
Programmers should not have to be aware of version-aware references, especially not have to distinguish between version-aware references and direct references.
There also should not be any direct references to particular versions of an object otherwise accessed through version-aware references, preventing inconsistencies.
In fact, programmers should not have to adapt their program code to use version-aware references.
Instead version-aware references should be provided consistently by the programming system.

Versions of the entire runtime could be created explicitly by the programmer or implicitly with each potentially manipulating user interaction.
Such actions could include directly manipulating attributes and composition of graphical elements, saving source code, evaluating do-its, and, for example, firing buttons of applications.
This way, programmers could undo each of those actions, regardless of whether the action was intended as mere exploration or turned out inappropriate more unexpectedly.
Using user actions as granularity for versions of the programming runtime allows developers to undo and redo the changes associated with concrete, rememberable actions.
Further, compared to saving every change to each object into separate versions, this granularity yields fewer versions for the programmer to consider in recovery situations.

\section{Object Versioning for the Lively Kernel}

Our approach for providing object versioning for the Lively Kernel uses proxies to implement version-aware references in JavaScript.
Further, we exchange ordinary references with proxies for all mutable objects by returning proxies whenever a new object is created.
This is done by transforming sources and by returning proxies from proxied constructors.
Simple global versions of the runtime to be used by the proxies suffice for basic recovery support in the single-threaded Lively Kernel programming system.

% Our proxies manage  transparently delegate to one among many versions for the same object, while they in this approach also manage the different versions for an object.
% 
% We rely on a combination of proxy behavior and source transformation to use the proxies consistently around all mutable objects.
% Besides these approaches for having and using version-aware references, a simple and linear versioning structure suffices to provide basic undo and redo capabilities.



\subsection{Proxies as Version-aware References}

implementation in javascript, so there are only actual references in JavaScript, but we can use objects that represent references that know multiple versions of objects.

but as resolving a version-aware reference should transparently result in a particular version of the object, these objects need to delegate transparently to that particular version.
for this, we use proxy objects, in particular we use the ECMAScript 6 Direct Proxies as implementation of version-aware references.

also we let the proxy objects hold all versions of an object instead of, for example, using object tables, so that when no object holds the version-aware reference any longer, the reference object with all versions of the actual object get garbage collected.



\subsection{Proxies For All Mutable Objects}

This ensures that references to proxies are used consistently instead of direct references to objects and that such proxies are used for every object.


use version-aware references consistently:
for all references between two objects use version-aware references instead. that is, all usual references need to become references to a proxy objects, which then reference one or multiple versions of the actual object.

given that proxy references are returned as such when reading object properties and variables, it is only necessary to immediately wrap objects when they are created to use proxy references consistently for the system. so, we return version-aware references / proxies instead of the usual references for all new objects that are created.

ways to create new objects in javascript: literals, constructor, specific built-in functions (Object.create.. eval..)

literals can be rewritten to be wrapped into proxies immediately. constructors are functions, which should already be proxied so that proxy behavior can be specified to return proxies for new instances, while specific built-in functions can be patched globally or rewritten for source to also return proxies.



\subsection{Versions of the Lively Runtime}

particular versions of the runtime

global version data structure for the runtime, runtime versions may have predecessors and may have successors, versions of objects get chosen using the current global version of the runtime

not necessarily necessary to copy each object for each version, but can be done on writes. further, not necessarily necessary to copy objects completely, but diffs or even delegation between diffs in a prototypical manner can be implemented
