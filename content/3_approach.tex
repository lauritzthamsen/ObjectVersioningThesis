\chapter{Object Versioning} \label{sec:APPROACH}

As explained in Section~\ref{sec:BACKGROUND}, programmers benefit from being able to recover previous development states without explicitly preparing for potential recovery needs.
We propose fine-grained object versioning for such recovery support in systems in which developers manipulate objects directly.
The programming system should preserve multiple versions of objects and should implement alternative references that transparently resolve to one of those versions.

Our approach for implementing this for the Lively Kernel in JavaScript relies on proxies and source transformations.
This provides a language-level solution for alternative references and object versioning.


\section{Version-aware References}

When changes made directly to objects turn out to be inappropriate, developers might want to re-establish a previous state of the programming system.
For this, we propose to save versions of objects and to use alternative, version-aware references.
Version-aware references should dynamically resolve to one of several versions of objects.
To change which version of an object is used, these references should not be updated.
Instead the version-aware references should resolve to the correct version of an object dynamically when used, thereby encapsulating the multiplicity of versions per object.
Other than that, version-aware references should behave like usual references.
They can be assigned to variables and be passed around.
A version of an object is in the simplest case a copy with its values for primitive values and object relations.
That is, version-aware references point to one out of many versions for a conceptually identical object, while objects are versioned in their entirety and not per property.
In particular, different versions might hold different version-aware references in the same instance variable or slot.
This also means versions of objects are also just objects in the programming runtime.

In the example shown by Figure~\ref{fig:EmployeeAddresses}, there are multiple versions for the \emph{address} property of an \emph{employee} object.
The reference stored for the address of the employee is aware of those versions.
When resolved, it chooses a particular version transparently, using some criteria to decide which version is currently supposed to be accessed, and returns that particular version.

\todo{figure 3.1: an object has a reference to multiple versions for the same object}

% \begin{figure}[h]
%     \centering
%     \includegraphics[width=\textwidth]{figures/EmployeeAddresses.png}
%     \caption{An object for an employee with different versions of his address.}
%     \label{fig:EmployeeAddresses}
% \end{figure}


Versions of objects are created and resolved coordinately to be able to resolve entire object graphs as they were at a particular moment.
For this, versions of objects created at the same time need to be relatable.
For example, annotating the versions of different objects that were created together with the same version information would allow to resolve all involved version-aware references to the versions of one runtime state.

Expanding our example, the address object might also hold version-aware references, while the employee object might be a particular version among many.
Figure Z2 shows a concrete and more comprehensive situation...
Mutiple versions for each object in this graph have been preserved together, each of those related versions of objects associated with the same version information, in this example named \emph{v1}, \emph{v2}, and \emph{v3}.
That is, when the \emph{company} object was preserved at the moment \emph{v1}, the \emph{person} object  was also like preserved in version v1.
Starting at object P now, we can resolve all object relations following the v1 annotations, thereby resolving the entire object graph as it was in version v1.

\todo{figure 3.2: an object graph with multiple version-aware references, showing relatable versions for different objects.. to be resolved to particular versions of the object graph together}

This way, when version-aware references are used consistently for all object relations in a programming runtime, the state of the entire runtime can be reset to particular versions.
However, this also only entails the programming runtime, while side effects to the state of other programs, for example server processes, or to databases cannot be reversed with this approach.

In addition, version-aware references should be transparent to programmers.
Programmers should not have to be aware of version-aware references, especially not have to distinguish between version-aware references and direct references.
There also should not be any direct references to particular versions of an object otherwise accessed through version-aware references, preventing inconsistencies.
In fact, programmers should not have to adapt their program code to use version-aware references.
Instead version-aware references should be provided consistently by the programming system.

Versions of the entire runtime could be created explicitly by the programmer or implicitly with each potentially manipulating user interaction.
Such actions could include directly manipulating attributes and composition of graphical elements, saving source code, evaluating do-its, and, for example, firing buttons of applications.
This way, programmers could undo each of those actions, regardless of whether the action was intended as mere exploration or turned out inappropriate more unexpectedly.
Using user actions as granularity for versions of the programming runtime allows developers to undo and redo the changes associated with concrete, rememberable actions.
Further, compared to saving every change to each object into separate versions, this granularity yields fewer versions for the programmer to consider in recovery situations.



\section{Object Versioning for the Lively Kernel}

Our approach for providing object versioning for the Lively Kernel uses proxies to implement version-aware references in JavaScript.
We exchange ordinary references with proxies for all mutable objects by returning proxies whenever a new object is created.
This is done by transforming sources to proxy object literals and constructor functions.
Further, the proxies return proxies again when they are used as constructors.
Also through proxy behavior and some global versioning data, we provide basic recovery support for the single-threaded Lively Kernel programming system.


\subsection{Proxies as Version-aware References}

We do not actually require an alternative kind of references for JavaScript to provide version-aware references.
Instead we can use ordinary references and proxy objects.
That is, each reference that would normally point directly to an object points to a proxy instead.
The proxies know how to access the actual versions for each object and delegate transparently to one particular among those.

we let the proxy objects hold all versions of an object instead of, for example, using object tables, so that when no object holds the version-aware reference any longer, the proxy object and all actual version objects get garbage collected.

fully virtual objects, intercept all kinds of access to the proxies and can handle that access arbitrarly.
our implementation delegates intercepted to the current version.

%  ECMAScript 6 Direct Proxies: fully virtual objects, traps to specify proxy behavior, traps for property reads, property writes, accessing the prototype, other meta programming... where we delegate each of those actions to the current version


\subsection{Proxies For All Mutable Objects}

This ensures that references to proxies are used consistently instead of direct references to objects and that such proxies are used for every object.

for all references that would normally relate two objects we need version-aware references instead.
that is, all usual references need to become references to proxy objects, which then reference one or multiple versions of the actual object.
also, two references to the same proxy object have to be identical as references to the same object are identical.
for this reason, we create a proxy as an object is created and return a reference to the proxy instead to the object.
this reference to the proxy is, thus, then passed around in the program as only access to the versioned object.
therefore, all access goes through the proxy and there are no direct references to the object.
further, identity that would usually compare the object with other objects now compares the proxy with other proxies.

for our approach, all expressions that create new objects need to return proxies for those objects instead.
there are three different ways to create an object in javascript: evaluating literal expressions, applying constructor functions, and calling specific built-in functions as, for example, the eval function.

we apply source transformation to wrap literal expressions in a function that creates and returns a proxy for the expression's result.
besides objects and arrays functions are also mutable objects in javascript.
therefore, we wrap the literal forms of objects, arrays, and functions.

in javascript, all functions can be constructors and create new objects when called with the new operator.
except, for built-in functions of JavaScript standard library all functions are expressed as function literals, which we transform to be wrapped by our proxies.
as the virtual object proxies we use for version-aware references intercept different object access differently, we can specify their construct behavior and let them return proxies for the newly created objects.

however, there are also built-in functions that create objects and that are not created from literal form.
therefore, these are not automatically proxied.
one category of such built-in functions are built-in constructors.
for example, the built-in data types like objects and arrays can be created by calling new Object or new Array.
we transform these built-in constructor functions explicity, wrapping each into the proxying function.
besides this category, there are also very specific built-in functions, that we transform separately to specific alternatives.
one example for such functions is the global eval function.
while the return value of that function also potentially needs to be a reference to a proxy instead of an ordinary object, eval takes arbitrary code which might express an arbitrary object structure where references also should not be directly between objects.
therefore, in the case of eval, we wrap eval, but also let the string argument to eval pass through our source transformations.


\subsection{Versions of the Lively Runtime}

developers can only effectively undo changes, which potentially affect many objects and are not necessarily fully known, when whole object graphs or even the entire runtime can be re-set to a particular state.
for this, the version-aware references for multiple objects need to resolve to versions that were saved together.
therefore, our proxies hold all versions for an object in a dictionary that connects version identifiers for actual objects.
which of these versions for each object should be chosen can be declared globally as javascript runs single-threaded and with cooperative scheduling and there is, thus, no possiblity to cause inconsistencies through accidentaly changing the global version within JavaScript while another JavaScript function is executed.
this global versioning information is an object that holds a version identifier, to be used by the proxies when deciding to which version they delegate, and may also have a predecessor and a successor.

this global versioning information with its potentially predecessor and successor can also be used to not copy every object for every preserved state of the runtime.
that is, when an object has not changed from one version to the next, it does not need to be copied.
the version-aware references could just follow the global information to return the last preserved version.

besides this copy-on-write optimization, another optimization would be to not copy objects completely, but to only store changes.
this could, for example, also apply prototypical inheritance to have versions that delegate to previous versions and only express the differences between versions.