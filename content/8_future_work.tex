\chapter{Future Work} \label{chapter:FUTURE_WORK}

In the future, we would like our solution to become more practically useful for developers.
As described in this chapter, this could be achieved by improving the performance of our implementation and providing tool support.

\section{Improving the Performance} \label{sec:FUTURE_WORK:1}

Our current implementation introduces a significant overhead to JavaScript execution as presented in Section~\ref{sec:EVALUATION:4}.
This also reduces the responsiveness of many Lively Kernel tools considerably.

Our proxy-based version-aware references trap read and write access and forward to the correct versions.
The correct versions are selected dynamically on access.
Thus, even for a single version of the system and only one version for each object, there is a constant overhead for resolving the version-aware references.
When we want to speed-up the execution of JavaScript code, we need to reduce the time it takes to resolve version-aware references.

Our implementation uses the Direct Proxies that the ECMAScript 6 standard will add to the JavaScript language.
As discussed in Section~\ref{sec:EVALUATION:4}, our specific proxy behavior---delegate to a changing version of an essentially unrelated object---is currently only an order of magnitude slower than the default behavior---delegate the access unchanged to the proxy's constant target.
A slowdown of two orders of magnitude is introduced just by using proxies, independent of any version-aware behavior.

There are three different approaches to improving the performance of our implementation of version-aware references:

\begin{description}
    \item[Faster proxies] The proxies are not yet fully supported by browsers and we expect better performance in the future.
    \item[Fewer proxies] Proxies could be used only for system parts for which state should be versioned.
    \item[An alternative to proxies] Instead of using the JavaScript proxies, similar custom indirections could be provided using JavaScript functions and source transformations.
\end{description}

\paragraph{Faster Proxies}
At the time of writing, the ECMAScript 6 specification that includes the Direct Proxies is only a draft.
We are able to use these proxies already because Chrome and Firefox implement earlier proposals of the proxies and a library provides the Direct Proxies on top of these, as discussed in Section~\ref{sec:IMPLEMENTATION:4}.
However, given that the Direct Proxies are marked as experimental feature in Chrome and currently partly implemented by JavaScript library instead by the JavaScript engines, it seems reasonable to expect performance improvements once ECMAScript 6 is finalized and implemented completely by the JavaScript engines.

\paragraph{Fewer Proxies}
We could use proxies less deliberately.
Objects for which always only a single version exist are not required to be proxied.
One example for a group of objects that do not need to be versioned are the intermediate results of the Lively Kernel's OMeta~\cite{Warth2007OOL} parser.
The parser creates many objects while parsing code.
These objects are only necessary during parsing, which in the end often only needs to return a success or failure.
In fact, given JavaScript's single-threaded and cooperative execution it would not even be possible to switch the system version during parsing.
So, there will be no previous versions for any of the objects only created as intermediate results of the parser.
The version-aware references to such temporary objects, however, still impede performance significantly.

\paragraph{An Alternative to Proxies}
Equivalent indirections as provided by the proxies can be faster when provided manually through custom JavaScript functions and source transformations, as discussed in Section~\ref{sec:EVALUATION:4}.
This suggests an alternative to using proxies.
We could still use objects as stand-ins for the versions of an object, but implement the delegation behavior with ordinary JavaScript functions.
These functions could be inserted automatically by source transformations.
The source transformations could look similar to the following transformation:

\begin{center}
    \begin{tabular}{ lll }
    \lstinline|obj.func()| & --> & \lstinline|apply(obj, get(obj, func))| \\
    \end{tabular}
\end{center}

From these three approaches, using an alternative to proxies promises the fastest results.
Using proxies only for parts of the system that should be versioned would only be sufficient if these parts would not require performance improvements, which they, however, currently do.
Waiting for faster proxy implementations in the JavaScript engine might work, but is no short-term solution as an release date for the ECMAScript 6 specification has not yet been announced.


\section{Providing Recovery Tools}

Our implementation allows to preserve and to re-establish versions of the the Lively Kernel runtime, but these versions currently still need to be created explicitly.
There is no tool support to find relevant versions, to merge changes, and to manage versions with branches.


\subsection{Preserving Versions Automatically}

Currently, developers still need to preserve particular versions, which they might, however, forget or even deliberately decide against after underestimating the risk of a change.
At the same time, it takes effort to assess the risk of upcoming changes, to run appropriate tests to check the current state, and to commit a version.
For these reasons, similar to CoExist, we want the system to preserve a fine-grained history automatically.
Developers should be able to recover versions that they have not explicitly preserved previously.

We could conceivably create versions of the runtime for any change to an object.
However, even if that were technically feasible, developers also need to be able to find and recognize the particular versions they want to recover state from.
Therefore, we want to preserve versions associated with actions of developers to allow developers to undo changes in easily identifiable chunks, whenever they recognize that actions did not exactly improve their programs.
In particular, the system could, for example, automatically preserve a version of the state whenever a developer does one of the following actions:
\begin{itemize}
    \item manipulate a graphical object directly with one of the Lively Kernel's halo tools or through drag and drop
    \item save or remove a script of an object or a method of a class
    \item evaluate a code snippet (``Do-It'')
    \item trigger code execution by clicking a button or pressing a key
\end{itemize}


\subsection{Tools For Finding and Managing Versions}

Tools should support developers in finding and re-establishing versions, in creating and deleting lines of histories, and in diffing and merging changes.

\subsubsection{Finding Relevant Versions}

Besides preserving versions continuously on a granularity helpful to developers, we also want to support developers in finding particular versions of the runtime by adding helpful information to each of the versions.
For each version the system could present three categories of information:

\begin{description}
    \item[when] Versions could be accompanied by a timestamp and be presented in a timelime as in CoExist to show relations between versions.
    \item[how] Versions could be annotated with the kind of action that triggered preserving the version such as whether a developer used a halo button or evaluated a code snippet. This could be supported by recording screenshots or even short screencasts for each version.
    \item[what] Versions could store information on what was changed between two version: which objects have changed, how these objects changed, and how this affected tests and benchmarks.
\end{description}

What source code changed can often be indicated by static information as, for example, a class, its module, and the containing file.
There is, however, less static information for objects.
In case of Livey, we might be able to present how they relate to the scenegraph of visible objects.
Further, some graphical objects do have explicit names in the Lively Kernel.
How objects changed between versions can be presented in a diff view for both state and behavior.

\subsubsection{Version Management}

When developers have recovery needs and also find the particular previous version they were looking for, they might want to revisit it for different purposes.
For example, developers might just want to re-establish a particular state of the system to see how an application behaved or looked at that moment.
Similarly, they might want to try an alternative idea without loosing all versions following the one they are currently revisiting.
That is, they might want to create a branch of changes as an alternative to the main line of versions.
Further, besides moving freely between versions of the runtime as well as creating and deleting lines of history, they also probably will want to recover particular state from particular versions.
Such state could be a particular version of a graphical application part they are working on, but also could be the state of a tool such as a code browser currently opened on a specific source code module.
For this, we want to support developers in copying particular state or whole objects from one version of the system to another.

