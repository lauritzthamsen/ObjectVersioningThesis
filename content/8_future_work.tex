\chapter{Future Work} \label{chapter:FUTURE_WORK}

In the future, we would like our solution to become more practically useful for developers.
As described in this chapter, this could be achieved by improving the performance of our implementation and providing tool support.


\section{Improving the Performance} \label{sec:FUTURE_WORK:1}

Our current implementation introduces a significant execution overhead as presented in Section~\ref{sec:EVALUATION:4}.
This also reduces the responsiveness of the Lively Kernel's tools considerably.

The version-aware references resolve to versions of objects dynamically: the right version is selected the moment the version-aware references need to be resolved.
Even though optimizations such as caching the current version are possible, a certain execution overhead is to be expected with this approach.\\
However, our evaluation showed that most of the current overhead is introduced by the proxies we used for implementing version-aware references.
Even when these proxies are configured to forward all interactions to a fixed target, it takes 200 times more time to have one of these proxies forward a property read than to read the property directly from the target.

There are three different approaches to this performance problem:

\begin{itemize}
    \item \textbf{Waiting for faster proxies}: The proxies we used are not yet fully supported by browsers and it seems reasonable to expect better performance in the future.
    \item \textbf{Using fewer proxies}: Proxies could be used only for the system parts for which state should be versioned.
    \item \textbf{Implementing an alternative to proxies}: Instead of using proxies, version-aware references could be implemented differently. For example, a similar indirection could be provided by source transformations and ordinary JavaScript functions.
\end{itemize}


\subsubsection{Waiting for Faster Proxies}

Our implementation uses the Direct Proxies that the ECMAScript 6 standard will add to the JavaScript language.
The ECMAScript 6 specification has not yet been finalized.
The current draft can be used in Chrome and Firefox, but is not fully implemented by their respective JavaScript engines.
Instead, the proxies are currently implemented partly by a JavaScript library and partly by the JavaScript engines.
In the future, the proxies will be implemented completely by the JavaScript engines.
This will likely reduce their execution overhead.\\
Moreover, it seems reasonable to assume that the performance of the current implementation of proxies has not yet been optimized.
It is, after all, an experimental feature that has not yet been officially added to JavaScript.

\subsubsection{Using Fewer Proxies}

We could use proxies less deliberately.
The state of some parts of the system could be excluded from versioning if access to previous states of such parts is not required.
Moreover, there are even objects for which predictably only one version will exist.

For example, one system part that could be excluded from versioning is the Lively Kernel's \emph{OMeta}~\cite{Warth2007OOL} parser.
The parser is, for example, used by to check for syntax errors before changes to code can be saved.
It creates many objects while parsing code.
Therefore, parsing takes much more time when all object interactions go through proxies.
These objects capture intermediate states of the parser, while in the end often only a success or failure is returned.
In fact, given JavaScript's single-threaded, cooperatively scheduled execution it would not even be possible to switch versions during parsing.
So, there would not be multiple versions of the objects available only while the parser runs.\\
The parser could, however, return objects as results or otherwise make objects available to other system parts.
When the objects are provided to versioned system parts, the objects could become part of the state of the versioned system parts.
They would then have to wrapped into proxies to be able the preserve the complete state of the versioned system parts.


\subsubsection{Implementing An Alternative to Proxies}

Version-aware references could be implemented without using proxies.

Ordinary JavaScript functions could be used to carry out object interactions on the right versions of objects.
These functions would be similar to the traps of our proxy handler \todo{ref to our proxy traps}.
For example, a \lstinline{get} function could allow reading a property from the current version of an object.
Its code could look similar to the following:

\iffalse
\begin{verbatim}\fi
\begin{code}[lst:getFunction]{}{float}
function get(standIn, propertyName) {
    var version = lively.getCurrentVersionOf(standIn);
    return version[propertyName];
}
\end{code}
\iffalse
\end{verbatim}\fi

The first parameter to this function would be an ordinary object that stands-in for the versions of an object.
The \lstinline{getCurrentVersionOf} function uses the \lstinline{standIn} parameter to retrieve the current version of an object.
For this, the \lstinline{standIn} object could hold the versions of an object or be a key to a dictionary.

Functions like the \lstinline{get} function could be inserted automatically by source transformations.
The source transformations to read a property \lstinline{age} from an object \lstinline{person} could look as follows:

\begin{center}
    \begin{tabular}{ lll }
    \lstinline|person.age| & --> & \lstinline|get(person, 'age')| \\
    \end{tabular}
\end{center}

Other object interactions could be handled in similar functions.
For example, an \lstinline{apply} function could apply a version of a function.

To call a function \lstinline{dance} of an object \lstinline{person} in a version of the system, two steps are necessary.
First, the \lstinline{dance} property has to be read from the right version of the \lstinline{person}.
Second, the right version of the \lstinline{dance} property, which is expected to be a function, needs to be applied.
Therefore, calling a function of an object would require to insert the \lstinline{get} function and the \lstinline{apply} function:

\begin{center}
    \begin{tabular}{ lll }
    \lstinline|person.dance()| & --> & \lstinline|apply(person, get(person, 'dance'))| \\
    \end{tabular}
\end{center}

When the \lstinline{dance} function is applied, the \lstinline{this} keyword needs to refer to the right version of the \lstinline{person} object, because the \lstinline{dance} function is a method of the \lstinline{person} object.
Therefore, the \lstinline{apply} function is called with the \lstinline{person} stand-in.

\subsubsection{Discussion of the Approaches}

Of the three approaches, using an alternative to proxies seems most promising.

Using proxies only for parts of the system that should be versioned would only be sufficient if these parts would not require performance improvements, which they, however, currently do.\\
Waiting for faster proxy implementations in the JavaScript engine is an option, but there is no official release date for the ECMAScript 6 specification yet.\\
Furthermore, early performance tests indicated that the suggested alternative implementation of version-aware references would actually be faster.
In particular, a microbenchmark showed that going through a function to read a property of an object is only twice as expensive as reading the property directly.


\section{Providing Recovery Tools}

Our implementation allows to preserve and re-establish versions of the Lively Kernel's state.
These versions currently still need to be created explicitly and there are no tools yet to find and manage versions.


\subsection{Preserving Versions Automatically}

With our implementation, programmers need to preserve versions to be able to re-establish them later.
Preserving versions is an effort.
It is difficult to assess the risk of upcoming changes when deciding whether a state needs to be preserved.
Programmers could deliberately decide against preserving a version after underestimating the risk of changes.
They might forget to preserve versions.
Moreover, it is time consuming to run appropriate tests to ensure that the current state is a good state to preserve.\\
For these reasons, we want the system to preserve a fine-grained history automatically.

The system could create versions of the runtime for any change to an object.
However, even if that were technically feasible, programmers need to be able to find and recognize relevant versions efficiently.
Therefore, we propose that the system records versions automatically as proposed by CoExist: preserve a version for each action of a programmer.

The Lively Kernel could automatically preserve versions whenever a developer does any of the following:
\begin{itemize}
    \item manipulate properties of a morph directly with a halo tool or through drag and drop
    \item add, remove, or edit a script of a morph or a method of a class
    \item evaluate a code snippet (``Do-It'')
    \item trigger code execution through a mouse or keyboard interaction
\end{itemize}

This way, whenever programmers realize changes were inappropriate, they can undo their actions.


\subsection{Tools For Finding and Managing Versions}

The system should support developers in finding and re-establishing relevant states.

\subsubsection{Finding Versions}

Besides preserving versions continuously on a granularity helpful to developers, we want the system to present helpful information to each version.
The system could present three categories of information:

\begin{description}
    \item[when] Versions could be accompanied by a timestamp and be presented in a timelime as in CoExist.
    \item[how] Versions could be annotated with the kind of action that triggered preserving the version such as whether a programmer used a halo button or evaluated a code snippet. This could be supported by recording screenshots or screencasts for versions.
    \item[what] Versions could store information on what was changed between two version: which objects did change, how these objects changed, and how this affected tests and benchmarks.
\end{description}

Changes can often be associated with static information as, for example, a class, a module, and a containing file.
Some objects as, for example, morphs could be related to the scenegraph of visible morphs.
Furthermore, morphs can have individual names in the Lively Kernel.

\subsubsection{Managing Versions}

When developers find a relevant previous state, they might want to use it for different purposes:

\begin{description}
    \item[Revisiting previous states] Programmers might want to re-establish a particular state of the system without making changes. For example, they might want to see how an application behaved at a particular moment to compare that to the current state.
    \item[Recovering previous states] Programmers might want to recover state from one version in another version. For example, they could want to recover a particular version of an application or the state of a tool such as a browser.
    \item[Trying alternatives] Programmers might want to try a new idea in an earlier version without loosing neither that version nor any following versions. Therefore, they might want to create a branch as an alternative to the main line of version history.
\end{description}

We want programmers to be able to re-visit versions of the system and to be able to create, merge, and delete lines of history.
Additionally, programmers should be able to copy particular objects from one version to another.
