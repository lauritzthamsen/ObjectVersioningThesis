\chapter{Future Work} \label{chapter:FUTURE_WORK}

In the future, we would like our solution to become more practically useful for developers.
As described in this chapter, this could be achieved by improving the performance of our implementation and providing tool support.

\section{Improving the Performance} \label{sec:FUTURE_WORK:1}

Our current implementation introduces a significant overhead to JavaScript execution as presented in Section~\ref{sec:EVALUATION:4}.
This also reduces the responsiveness of many Lively Kernel tools considerably.

Our proxy-based version-aware references trap read and write access and forward to the correct versions.
The correct versions are selected dynamically on access.
Thus, even for a single version of the system and only one version for each object, there is a constant overhead for resolving the version-aware references.
When we want to speed-up the execution of JavaScript code, we need to reduce the time it takes to resolve version-aware references.

Our implementation uses the Direct Proxies that the ECMAScript 6 standard will add to the JavaScript language.
As discussed in Section~\ref{sec:EVALUATION:4}, our specific proxy behavior---delegate to a changing version of an essentially unrelated object---is currently only an order of magnitude slower than the default behavior---delegate the access unchanged to the proxy's constant target.
A slowdown of two orders of magnitude is introduced just by using proxies, independent of any version-aware behavior.

There are three different approaches to improving the performance of our implementation of version-aware references:

\begin{description}
    \item[Faster proxies] The proxies are not yet fully supported by browsers and we expect better performance in the future.
    \item[Fewer proxies] Proxies could be used only for system parts for which state should be versioned.
    \item[An alternative to proxies] Instead of using the JavaScript proxies, similar custom indirections could be provided using JavaScript functions and source transformations.
\end{description}

\paragraph{Faster Proxies}
At the time of writing, the ECMAScript 6 specification that includes the Direct Proxies is only a draft.
We are able to use these proxies already because Chrome and Firefox implement earlier proposals of the proxies and a library provides the Direct Proxies on top of these, as discussed in Section~\ref{sec:IMPLEMENTATION:4}.
However, given that the Direct Proxies are marked as experimental feature in Chrome and currently partly implemented by JavaScript library instead by the JavaScript engines, it seems reasonable to expect performance improvements once ECMAScript 6 is finalized and implemented completely by the JavaScript engines.

\paragraph{Fewer Proxies}
We could use proxies less deliberately.
Objects for which always only a single version exist are not required to be proxied.
One example for a group of objects that do not need to be versioned are the intermediate results of the Lively Kernel's OMeta~\cite{Warth2007OOL} parser.
The parser creates many objects while parsing code.
These objects are only necessary during parsing, which in the end often only needs to return a success or failure.
In fact, given JavaScript's single-threaded and cooperative execution it would not even be possible to switch the system version during parsing.
So, there will be no previous versions for any of the objects only created as intermediate results of the parser.
The version-aware references to such temporary objects, however, still impede performance significantly.

\paragraph{An Alternative to Proxies}
Equivalent indirections as provided by the proxies can be faster when provided manually through custom JavaScript functions and source transformations, as discussed in Section~\ref{sec:EVALUATION:4}.
This suggests an alternative to using proxies.
We could still use objects as stand-ins for the versions of an object, but implement the delegation behavior with ordinary JavaScript functions.
These functions could be inserted automatically by source transformations.
The source transformations could look similar to the following transformation:

\begin{center}
    \begin{tabular}{ lll }
    \lstinline|obj.func()| & --> & \lstinline|apply(obj, get(obj, func))| \\
    \end{tabular}
\end{center}

From these three approaches, using an alternative to proxies seems most promising.
Using proxies only for parts of the system that should be versioned would only be sufficient if these parts would not require performance improvements, which they, however, currently do.
Waiting for faster proxy implementations in the JavaScript engine might work, but is no short-term solution as an release date for the ECMAScript 6 specification has not yet been announced.



\section{Providing Recovery Tools}

Our implementation allows to preserve and re-establish versions of the Lively Kernel's state.
These versions currently still need to be created explicitly and there are no tools yet to find and manage versions.


\subsection{Preserving Versions Automatically}

With our implementation, programmers need to preserve versions to be able to re-establish them later.
Preserving versions is an effort.
It is difficult to assess the risk of upcoming changes when deciding whether a state needs to be preserved.
Programmers could deliberately decide against preserving a version after underestimating the risk of changes.
They might forget to preserve versions.
Moreover, it is time consuming to run appropriate tests to ensure that the current state is a good state to preserve.\\
For these reasons, we want the system to preserve a fine-grained history automatically.

The system could create versions of the runtime for any change to an object.
However, even if that were technically feasible, programmers need to be able to find and recognize relevant versions efficiently.
Therefore, we propose that the system records versions automatically as proposed by CoExist: preserve a version for each action of a programmer.

The Lively Kernel could automatically preserve versions whenever a developer does any of the following:
\begin{itemize}
    \item manipulate properties of a morph directly with a halo tool or through drag and drop
    \item add, remove, or edit a script of a morph or a method of a class
    \item evaluate a code snippet (``Do-It'')
    \item trigger code execution through a mouse or keyboard interaction
\end{itemize}

This way, whenever programmers realize changes were inappropriate, they can undo their actions.

\subsection{Tools For Finding and Managing Versions}

The system should support developers in finding and re-establishing relevant states.

\subsubsection{Finding Relevant Versions}

Besides preserving versions continuously on a granularity helpful to developers, we want the system to present helpful information to each version.
The system could present three categories of information:

\begin{description}
    \item[when] Versions could be accompanied by a timestamp and be presented in a timelime as in CoExist.
    \item[how] Versions could be annotated with the kind of action that triggered preserving the version such as whether a programmer used a halo button or evaluated a code snippet. This could be supported by recording screenshots or screencasts for versions.
    \item[what] Versions could store information on what was changed between two version: which objects did change, how these objects changed, and how this affected tests and benchmarks.
\end{description}

Changes can often be associated with static information as, for example, a class, a module, and a containing file.
Some objects as, for example, morphs could be related to the scenegraph of visible morphs.
Furthermore, morphs can have individual names in the Lively Kernel.

\subsubsection{Version Management}

When developers find a relevant previous state, they might want to use it for different purposes:

\begin{description}
    \item[Revisiting previous states] Programmers might want to re-establish a particular state of the system without making changes. For example, they might want to see how an application behaved at a particular moment to compare that to the current state.
    \item[Recovering previous states] Programmers might want to recover state from one version in another version. For example, they could want to recover a particular version of an application or the state of a tool such as a browser. 
    \item[Trying alternatives] Programmers might want to try a new idea in an earlier version without loosing neither that version nor any following versions. Therefore, they might want to create a branch as an alternative to the main line of version history.
\end{description}

We want programmers to be able to re-visit versions of the system and to be able to create, merge, and delete lines of history.
Additionally, programmers should be able to copy particular objects from one version to another.
