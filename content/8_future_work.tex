\chapter{Future Work} \label{chapter:FUTURE_WORK}

In the future, we want to make our solution more practically useful for developers.
As described in this section, we want to improve the performance of our implementation and provide appropriate tool support to developers.

\todo{once the other chapters are written, i need to check the references of this chapter}


\section{Improving the Performance of Our Implementation} \label{sec:FUTURE_WORK:1}


Our current implementation reduces the speed of JavaScript code execution and responsiveness of the development tools in the Lively Kernel considerably, as presented in Section~\ref{sec:DISCUSSION:2}.
Our proxy-based version-aware references select dynamically to which version of an object any access should be delegated.
Therefore, even for a single version of the runtime and, thus, only one version for each object, there is a constant overhead for resolving the version-aware references to their targets.
Thus, when we want to speed-up the execution of JavaScript code, we need to reduce the time it takes to resolve a version-aware references, which is currently done by having proxies intercept and forward access to the correct target.

There are three different approaches to a better performance of the system when version-aware references are used:

\begin{itemize}
    \item Faster proxies:
    \item Fewer proxies:
    \item Alternative proxies:
\end{itemize}


\subsubsection{Faster Proxies}
We use the Direct Proxies that the ECMAScript 6 standard will add to the JavaScript language.
As discussed in Section~\ref{sec:DISCUSSION:2}, our specific proxy behavior---delegate to a changing version of an essentially unrelated object---is currently only an order of magnitude slower than the default behavior---delegate the access unchanged to the proxy's constant target.
Two orders of magnitude are introduced just by using proxies, independent of any version-awareness.

At the time of writing, the ECMAScript 6 specification is still only a draft.
We are able to use these proxies already because the Chrome browser implements an earlier, now deprecated specification of the proxies as an experimental feature and because there is a library that provides the currently specified Direct Proxies on top of the deprecated style of proxies, as also discussed in Section~\ref{sec:IMPLEMENTATION:1}.
However, given that the proxies are marked as experimental feature in Chrome and currently partly implemented as JavaScript library---instead by the JavaScript engine--- as well as on top of the deprecated variant, it seems reasonable to expect performance gains once ECMAScript 6 gets finalized and implemented by the browser vendors.

\subsubsection{Fewer Proxies}
We could use proxies less deliberately and especially not for objects for which we wont have different versions anyways.
One example for a system part that would not need to version objects would be one of the Lively Kernel's parsers.
The particular parser, based on the JavaScript implementation of OMeta~\cite{Warth2007OOL}, creates many objects while parsing code.
These objects are only necessary during parsing, which often only needs to return a success or failure.
In fact, given JavaScript's single-threaded and cooperative execution it would not even be possible to switch the version during parsing with the current implementation.
So, there wont, for example, be multiple versions for any of the objects only created as intermediate results of a parser, rendering version-aware reference to such temporary objects irrelevant, while they, however, currently still impede performance significantly.

\subsubsection{Alternative Proxies}
Another indicator that proxies could be faster is that equivalent indirections as provided with the proxy handler traps are significantly faster when they are provided manually through custom JavaScript functions and source transformations, as indicated in Section~\ref{sec:DISCUSSION:2}.
This suggests an alternative implementation to using the Direct Proxies.
We could still use objects as stand-ins for a multiplicity of versions, but implement the delegation behavior currently provided in proxy traps with ordinary JavaScript functions, which we could use consistently instead of direct object access through further source transformations.\\
These source transformations could do something similar to the following:

\begin{center}
    \begin{tabular}{ lll }
    \lstinline|obj.func()| & --> & \lstinline|apply(obj, get(obj, func))| \\
    \end{tabular}
\end{center}


\section{Providing Recovery Tools}

Our implementation allows to preserve and to re-establish versions of the the Lively Kernel runtime, but these versions need currently to be created explicitly.
Developers still need to preserve particular versions, which developers might, however, forget or deliberately decide against after underestimating the risk of a change.
At the same time, it takes effort to assess the risk of upcoming changes, to run appropriate tests to check the current state, and to commit a version.
For these reasons and as suggested by CoExist, we want the system to preserve a fine-grained history automatically.
Developers should be able to recover versions that they have not explicitly preserved previously.
This includes that developers also need to be able to find the versions they are looking for.

We could conceivably create versions of the runtime for any change to an object.
However, even if that were technically feasible, developers also need to be able to find and recognize the particular versions they want to recover state from.
Therefore, we propose to preserve versions associated with actions of developers, to allow developers to undo the effects of their actions when they recognize actions did not exactly improve their programs.
In particular, the system could, for example, automatically preserve a version of the state whenever a developer does one of the following actions:
\begin{itemize}
    \item manipulate a graphical object directly with one of the Lively Kernel's halo tools or through drag and drop
    \item evaluate a code snippet (``Do-It'')
    \item save a script of an object or a method of a class
    \item trigger code execution by clicking a button or pressing a key
\end{itemize}

Besides preserving versions continuously on a granularity helpful to the users, we also want to support developers in finding particular versions of the runtime by adding helpful information to each of the versions.
Versions can be presented in relation to each other in, for example, a timeline as also provided by CoExist.
This way developers could see the order of their actions and for each version of the runtime, which versions preceded and which versions followed.
Such a timeline could also present timestamps for the versions.
Another helpful information would probably be the action that triggered preserving a version such as whether a developer used a halo button or evaluated a code snippet.
This could be supported by recording screenshots or even short screencasts for each version.
A third category of helpful information for a version, besides when and why a version was preserved, could be information on what was changed between two version: which objects have changed and how objects changed.
What source code changed can often be indicated by static information as, for example, a class, its module, and the containing file.
There is, however, less static information for objects.
In case of Livey, we might be able to present how they relate to the scenegraph of visible objects.
Further, some graphical objects do have explicit names in the Lively Kernel.
How objects changed between versions can be presented in a diff view for both state and behavior.
Lastly, the system could also provide information on the impact of changes: For each version, we could also preserve results for test cases and benchmarks.

When developers have recovery needs and also find the particular previous version they were looking for, they might want to revisit it for different purposes.
For example, developers might just want to re-establish a particular state of the system to see how an application behaved or looked at that moment.
Similarly, they might want to try an alternative idea without loosing all versions following the one they are currently revisiting.
That is, they might want to create a branch of changes as an alternative to the main line of versions.
Further, besides moving freely between versions of the runtime as well as creating and deleting lines of history, they also probably will want to recover particular state from particular versions.
Such state could be a particular version of a graphical application part they are working on, but also could be the state of a tool such as a code browser currently opened on a specific source code module.
For this, we want to support developers in copying particular state or whole objects from one version of the runtime to another.

All in all, this tool support for recovery should allow developers to find and re-establish versions, to create and delete lines of histories, and to diff and merge changes from one version of the system to another.

% \todo{add idea of robert krahn?}
% a specific interesting tool would be one that could be used to compare two versions of the state / two states, to not only see differences between two arbitrary states but more importantly to understand the impact/side effects of particular operations.. if i execute this script, what happens (especially besides visible side-effects..)