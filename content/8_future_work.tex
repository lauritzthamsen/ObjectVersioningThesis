\chapter{Future Work} \label{chapter:FUTURE_WORK}

In the future, we want to make our solution more practically useful for developers.
As described in this chapter, we want to improve the performance of our implementation and provide appropriate tool support to developers.

\todo{once the other chapters are written, i need to check the references of this chapter}


\section{Improving the Performance of Our Implementation} \label{sec:FUTURE_WORK:1}

Our current implementation reduces the speed of JavaScript code execution and, with that, also the responsiveness of many of the tools of the Lively Kernel considerably, as presented in Section~\ref{sec:DISCUSSION:2}.
Our proxy-based version-aware references select dynamically to which version of an object any access should be delegated.
Therefore, even for a single version of the runtime and, thus, only one version for each object, there is a constant overhead for resolving the version-aware references.
Thus, when we want to speed-up the execution of JavaScript code, we need to reduce the time it takes to resolve a version-aware references, which is currently done by having proxies intercept and forward access to the correct target.

We use the Direct Proxies that the ECMAScript 6 standard will add to the JavaScript language.
As discussed in Section~\ref{sec:DISCUSSION:2}, our specific proxy behavior---delegate to a changing version of an essentially unrelated object---is currently only an order of magnitude slower than the default behavior---delegate the access unchanged to the proxy's constant target.
Two orders of magnitude are introduced just by using proxies, independent of any version-awareness.

There are three different approaches to a better performance of the system when version-aware references are used:

\begin{description}
    \item[Faster proxies] The proxies are not yet fully supported by browsers and it seems reasonable to expect better performance in the future.
    \item[Fewer proxies] Proxies could be used only for system parts for which state should be versioned.
    \item[Alternative proxies] Instead of using the JavaScript proxies, similar and currently faster indirections could be provided by JavaScript functions and further source transformations.
\end{description}

\paragraph{Faster Proxies}
At the time of writing, the ECMAScript 6 specification is still only a draft.
We are able to use these proxies already because the Chrome browser implements an earlier, now deprecated specification of the proxies as an experimental feature and because there is a library that provides the Direct Proxies on top of the deprecated style of proxies, as also discussed in Section~\ref{sec:IMPLEMENTATION:1}.
However, given that the proxies are marked as experimental feature in Chrome and currently partly implemented as JavaScript library---instead by the JavaScript engine--- as well as on top of the deprecated variant, it seems reasonable to expect performance gains once ECMAScript 6 gets finalized and implemented by the JavaScript engines.

\paragraph{Fewer Proxies}
We could use proxies less deliberately and especially not for objects for which we wont have different versions anyways.
One example for a system part that would not need to version objects would be one of the Lively Kernel's parsers.
The particular parser, based on the JavaScript implementation of OMeta~\cite{Warth2007OOL}, creates many objects while parsing code.
These objects are only necessary during parsing, which often only needs to return a success or failure.
In fact, given JavaScript's single-threaded and cooperative execution it would not even be possible to switch the version during parsing with the current implementation.
So, there wont, for example, be multiple versions for any of the objects only created as intermediate results of a parser, rendering version-aware reference to such temporary objects irrelevant, while they, however, currently still impede performance significantly.

\paragraph{Alternative Proxies}
Equivalent indirections as provided with the proxy handler traps can be significantly faster when provided manually through custom JavaScript functions and source transformations, as indicated in Section~\ref{sec:DISCUSSION:2}.
This suggests an alternative to using the Direct Proxies.
We could still use objects as stand-ins for the many versions of an object, but implement the delegation behavior currently provided in proxy traps with ordinary JavaScript functions, which we could use consistently through further source transformations.\\
These source transformations could look similar to the following transformation:

\begin{center}
    \begin{tabular}{ lll }
    \lstinline|obj.func()| & --> & \lstinline|apply(obj, get(obj, func))| \\
    \end{tabular}
\end{center}

From these three approaches, implementing an alternative to the ECMAScript 6 proxies promises the best short-term results.
Using proxies only for parts of the system that should be versioned would only be a sufficient optimization if these parts would not require a speedup, which they, however, currently do.
Waiting for faster proxy implementations in the JavaScript engine might work, but is no short-term solution as there is no official due date for the ECMAScript 6 specification yet.


\section{Providing Recovery Tools}

Our implementation allows to preserve and to re-establish versions of the the Lively Kernel runtime, but these versions currently still need to be created explicitly.
There is no tool support to find relevant versions, to merge changes, and to manage versions with branches.


\subsection{Preserving Versions Automatically}

Currently, developers still need to preserve particular versions, which they might, however, forget or even deliberately decide against after underestimating the risk of a change.
At the same time, it takes effort to assess the risk of upcoming changes, to run appropriate tests to check the current state, and to commit a version.
For these reasons, similar to CoExist, we want the system to preserve a fine-grained history automatically.
Developers should be able to recover versions that they have not explicitly preserved previously.

We could conceivably create versions of the runtime for any change to an object.
However, even if that were technically feasible, developers also need to be able to find and recognize the particular versions they want to recover state from.
Therefore, we want to preserve versions associated with actions of developers to allow developers to undo changes in easily identifiable chunks, whenever they recognize that actions did not exactly improve their programs.
In particular, the system could, for example, automatically preserve a version of the state whenever a developer does one of the following actions:
\begin{itemize}
    \item manipulate a graphical object directly with one of the Lively Kernel's halo tools or through drag and drop
    \item save or remove a script of an object or a method of a class
    \item evaluate a code snippet (``Do-It'')
    \item trigger code execution by clicking a button or pressing a key
\end{itemize}


\subsection{Tools For Finding and Managing Versions}

Tools should support developers in finding and re-establishing versions, in creating and deleting lines of histories, and in diffing and merging changes.

\subsubsection{Finding Relevant Versions}

Besides preserving versions continuously on a granularity helpful to developers, we also want to support developers in finding particular versions of the runtime by adding helpful information to each of the versions.
For each version the system could present three categories of information:

\begin{description}
    \item[when] Versions could be accompanied by a timestamp and be presented in a timelime as in CoExist to show relations between versions.
    \item[how] Versions could be annotated with the kind of action that triggered preserving the version such as whether a developer used a halo button or evaluated a code snippet. This could be supported by recording screenshots or even short screencasts for each version.
    \item[what] Versions could store information on what was changed between two version: which objects have changed, how these objects changed, and how this affected tests and benchmarks.
\end{description}

What source code changed can often be indicated by static information as, for example, a class, its module, and the containing file.
There is, however, less static information for objects.
In case of Livey, we might be able to present how they relate to the scenegraph of visible objects.
Further, some graphical objects do have explicit names in the Lively Kernel.
How objects changed between versions can be presented in a diff view for both state and behavior.

\subsubsection{Version Management}

When developers have recovery needs and also find the particular previous version they were looking for, they might want to revisit it for different purposes.
For example, developers might just want to re-establish a particular state of the system to see how an application behaved or looked at that moment.
Similarly, they might want to try an alternative idea without loosing all versions following the one they are currently revisiting.
That is, they might want to create a branch of changes as an alternative to the main line of versions.
Further, besides moving freely between versions of the runtime as well as creating and deleting lines of history, they also probably will want to recover particular state from particular versions.
Such state could be a particular version of a graphical application part they are working on, but also could be the state of a tool such as a code browser currently opened on a specific source code module.
For this, we want to support developers in copying particular state or whole objects from one version of the runtime to another.

