\chapter{Future Work} \label{chapter:FUTURE_WORK}

In the future, we would like our solution to become more practically useful for developers.
As described in this chapter, this could be achieved by improving the performance of our implementation and providing tool support.

\section{Improving the Performance} \label{sec:FUTURE_WORK:1}

Our current implementation introduces a significant overhead to JavaScript execution as presented in Section~\ref{sec:EVALUATION:4}.
This also reduces the responsiveness of many Lively Kernel tools considerably.

Our proxy-based version-aware references trap read and write access and forward to the correct versions.
The correct versions are selected dynamically on access.
Thus, even for a single version of the system and only one version for each object, there is a constant overhead for resolving the version-aware references.
When we want to speed-up the execution of JavaScript code, we need to reduce the time it takes to resolve version-aware references.

Our implementation uses the Direct Proxies that the ECMAScript 6 standard will add to the JavaScript language.
As discussed in Section~\ref{sec:EVALUATION:4}, our specific proxy behavior---delegate to a changing version of an essentially unrelated object---is currently only an order of magnitude slower than the default behavior---delegate the access unchanged to the proxy's constant target.
A slowdown of two orders of magnitude is introduced just by using proxies, independent of any version-aware behavior.

There are three different approaches to improving the performance of our implementation of version-aware references:

\begin{description}
    \item[Faster proxies] The proxies are not yet fully supported by browsers and we expect better performance in the future.
    \item[Fewer proxies] Proxies could be used only for system parts for which state should be versioned.
    \item[An alternative to proxies] Instead of using the JavaScript proxies, similar custom indirections could be provided using JavaScript functions and source transformations.
\end{description}

\paragraph{Faster Proxies}
At the time of writing, the ECMAScript 6 specification that includes the Direct Proxies is only a draft.
We are able to use these proxies already because Chrome and Firefox implement earlier proposals of the proxies and a library provides the Direct Proxies on top of these, as discussed in Section~\ref{sec:IMPLEMENTATION:4}.
However, given that the Direct Proxies are marked as experimental feature in Chrome and currently partly implemented by JavaScript library instead by the JavaScript engines, it seems reasonable to expect performance improvements once ECMAScript 6 is finalized and implemented completely by the JavaScript engines.

\paragraph{Fewer Proxies}
We could use proxies less deliberately.
Objects for which always only a single version exist are not required to be proxied.
One example for a group of objects that do not need to be versioned are the intermediate results of the Lively Kernel's OMeta~\cite{Warth2007OOL} parser.
The parser creates many objects while parsing code.
These objects are only necessary during parsing, which in the end often only needs to return a success or failure.
In fact, given JavaScript's single-threaded and cooperative execution it would not even be possible to switch the system version during parsing.
So, there will be no previous versions for any of the objects only created as intermediate results of the parser.
The version-aware references to such temporary objects, however, still impede performance significantly.

\paragraph{An Alternative to Proxies}
Equivalent indirections as provided by the proxies can be faster when provided manually through custom JavaScript functions and source transformations, as discussed in Section~\ref{sec:EVALUATION:4}.
This suggests an alternative to using proxies.
We could still use objects as stand-ins for the versions of an object, but implement the delegation behavior with ordinary JavaScript functions.
These functions could be inserted automatically by source transformations.
The source transformations could look similar to the following transformation:

\begin{center}
    \begin{tabular}{ lll }
    \lstinline|obj.func()| & --> & \lstinline|apply(obj, get(obj, func))| \\
    \end{tabular}
\end{center}

From these three approaches, using an alternative to proxies promises the fastest results.
Using proxies only for parts of the system that should be versioned would only be sufficient if these parts would not require performance improvements, which they, however, currently do.
Waiting for faster proxy implementations in the JavaScript engine might work, but is no short-term solution as an release date for the ECMAScript 6 specification has not yet been announced.


\section{Providing Recovery Tools}

Our implementation allows to preserve and re-establish versions of the Lively Kernel system.
These versions currently still need to be created explicitly and there is a need for tool support to find and manage versions.


\subsection{Preserving Versions Automatically}

With our implementation, programmers need to preserve particular versions explicitly.
Preserving versions explicitly is a significant effort.
It is time consuming to assess the risk of upcoming changes, run appropriate tests to check the current state, and commit a version.
Moreover, programmers might forget to preserve versions or even deliberately decide against it after underestimating the risk of changes.
For these reasons, we want the system to preserve a fine-grained history automatically.

The system could create versions of the runtime for any change to an object.
However, even if that were technically feasible, programmers need to be able to find and recognize relevant versions efficiently.
Therefore, we propose that the system creates versions continuously as proposed by CoExist.
This allows developers to undo their actions whenever they recognize that the actions did not improve the state of their applications or the programming environment.

The Lively Kernel could automatically preserve versions of the system whenever a developer does any of the following:
\begin{itemize}
    \item manipulate properties of a morph directly with a halo tool or through drag and drop
    \item add, remove, or edit a script of a morph or a method of a class
    \item evaluate a code snippet (``Do-It'')
    \item trigger code execution by with a mouse or keyboard interaction
\end{itemize}

\subsection{Tools For Finding and Managing Versions}

The system should support developers in finding and re-establishing relevant states with dedicated tools.

\subsubsection{Finding Relevant Versions}

Besides preserving versions continuously on a granularity helpful to developers, we want the system to present helpful information to each version.
The system could present three categories of information:

\begin{description}
    \item[when] Versions could be accompanied by a timestamp and be presented in a timelime as in CoExist.
    \item[how] Versions could be annotated with the kind of action that triggered preserving the version such as whether a programmer used a halo button or evaluated a code snippet. This could be supported by recording screenshots or screencasts for versions.
    \item[what] Versions could store information on what was changed between two version: which objects did change, how these objects changed, and how this affected tests and benchmarks.
\end{description}

The change can often be associated with static information as, for example, a class, a module, and a containing file.
For some objects as, for example, morphs the Lively Kernel could show these static information, but in addition also relate the object to the scenegraph of visible morphs.
Furthermore, some morphs have individual names.

\subsubsection{Version Management}

When developers have recovery needs and also find the particular previous state they are looking for, they might want to revisit it for different purposes:

\begin{description}
    \item[Revisiting previous states] Programmers might want to re-establish a particular state of the system without making changes. For example, they might want to see how an application behaved or appeared at a particular moment without changing neither that state nor the most recent version.
    \item[Trying alternatives] Programmers might want to try an alternative without loosing all versions following the one they are currently revisiting. Therefore, they might want to create a branch as an alternative to the main line of version history.
    \item[Recovering previous states] Programmers might want to recover state from one version for another version. For example, they could want to recover a particular version of an application or the state of a tool such as a browser. 
\end{description}

We want programmers to be able to re-visit versions of the system and to be able to create, merge, and delete lines of history.
Additionally, programmers should be able to copy particular objects from one version to another.
