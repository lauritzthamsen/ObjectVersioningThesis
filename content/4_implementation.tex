\section{Implementation} \label{sec:IMPLEMENTATION}


\subsection{details of the proxies (3.2)}

\begin{itemize}
    \item ECMAScript 6 Direct Proxies: proxy handler object, traps; ES 6 in DRAFT, deprecated Harmony Proxy proposal implemented in current chromes, but 
    \item proxies for mutable JavaScript objects: objects, arrays, functions
    \item the proxy handlers really hold references to copies of the same object in a dictionary (version name -> object version)
    \item delegation to a particular version at runtime using a version of the target object according to some global version of the runtime..
    \item identity of proxyFor(obj) === proxyFor(obj), ProxyTable (weak-key map, objects -> to their proxies)
\end{itemize}



proxy implementation limitations: 
\begin{itemize}
    \item proxies as prototypes (relation can’t be changed.. traps of proto fire when inheriting object is accessed.. problem is Chrome and only the proto case...)... protoProxy property on objects..
    \item no instanceof trap, Object.instanceOf source transformation 
    \item [native code] boundary / primitive functions and objects: setting properties / calling functions leads to errors or has absolutely no effect: part 1: traps (sep-trap: onreadystatechange, apply-trap: any DOM function.., Array.prototype.concat, aWorker.postMessage.. multi-level unwrapping for args object, aFunc.apply or aFunc.call).
part 2: patches: Object.isRegExp, ‘some string’.match (done by patching String.prototype.match)
\end{itemize}


\begin{itemize}
    \item DOM redrawing on undo / redo: DOM is out of versioning scope, doesn’t use version-aware references, has to be changed / redrawn on undo/redo explicitly
\end{itemize}




\subsection{"details of ‘using the version-aware references consistently’” ( / details for 3.3)}

goal: all references to newly created objects need to be version-aware references, i.e. references to proxies instead of references to the (initial version of the) target. 

\begin{itemize}
    \item value of literal expressions: source transformations (objects, arrays, function expressions), examples.. function declarations and hoisting, literal accessor functions in object literals
    \item return value of custom constructors: construct-trap (..code for the construct / apply traps of the proxies..)
    \item return value of specific built-in functions and constructors: source transformations (only in the lexical scope of some particular modules, e.g. not for our implementation)
\end{itemize}

[what about all other source transformations..??]

% \begin{itemize}
%     \item why UglifyJS: fast, complete, testing alternative grammar rules during parsing is not implemented using execeptions, provides source maps (all in contrast to OMeta)
% \end{itemize}



\subsection{details for the versions of the runtime (details for 3.4)}

JS execution: single-threaded, cooperative scheduling 

\begin{itemize}
    \item global versions, linear versioning, data structure is an version object with a predecessor and a successor
    \item copy-on-write for versions of objects (set-trap, apply-trap for some array methods)
\end{itemize}


\begin{itemize}
    \item source transformations enabled right after the object versioning code, i.e. the implementation of the proxies and the source transformation, which are both themselves javascript code, gets loaded. by patching the eval that is used for evaluated modules that get loaded with an eval(transformSource.. so modules aren’t versioned, but classes / layers / traits are.. e.g. a class is versioned, so in different versions there might be different class-side state... so, for example, modules are currently in our implementation the roots of the version-aware reference graphs that prevent garbage collection, 
\end{itemize}


\begin{itemize}
    \item undo / redo implementation, example situation
    \item redraw of the world as DOM objects / DOM relations are not part of the object versioning in JavaScript
\end{itemize}




\subsection{asynchronous scripts / concurrency in JavaScript}

single-threaded and cooperative scheduling, but setTimeout / setInterval… stop asynchronous actions from following versions when undoing… source transformations, which scripts belongs to which version




\subsection{Implementation limitations}

\begin{itemize}
    \item only works in recent Chromes, with experimental JavaScript… ECMAScript 6 Direct Proxies not yet fully implemented, not yet stable.. 
.. own adaptions to the shim library, to bridge the gap between the current version of the shim and information from the Spec draft (pass null for the target of a proxy)… fully virtual objects vs. consistency checks.. adapted library to fit spec draft (pass null as target of a fully virtual object, then no trap-return-value-consistency-with-target checks)
\end{itemize}
    


\begin{itemize}
    \item debugging: lots of ‘low-level’/framework frames, dev tools don’t handle proxies well (hovering, labels, stepping into)
\end{itemize}
