% I. Background and context (problem area and motivation) 
% II. However (problem description)
% III. So what? (problem dimension) 
% IV. Deficiencies with previous approaches
% IV. Solution

\chapter{Introduction} \label{chapter:INTRODUCTION}

% Background

programming systems that allow development at runtime, like LISP or python REPL or Squeak/Smalltalk, change the programs as it runs, immediate feedback
[geht um programmiersysteme, in denen ... spannend ]

[eine unterkategorie dieser programmiersysteme ] programmverhalten nicht nur über klassen, sondern auch durch objekte definieren.. wie self und lively..
prototype-based object oriented programming (Self, JavaScript), objects (not classes) as programming unit, applications can be expressed solely with objects and these can be edited at runtime, in contrast to many other object-oriented systems, in which programmers develop the source code of classes
werte von objekten inspekten, ändern. verhalten ansehen und ändern.
The results of such development is the state of actual objects, not source code that abstractly describes potential objects.

Lively Kernel~\cite{Ingalls2008LKS,Krahn2009LWD}.. designed to allow a certain kind of development.. direct manipulation with immediate feedback.
art der entwicklung unterscheidet sich.. support for trying ideas immediately..encourages to directly change particular objects.
extra werkzeuge... Developers are able to make changes directly and receive immediate feedback
for this, Lively provides tools to directly manipulate the style, the graphical composition, and the scripts of particular objects. 
development happens at runtime, composition and other manipulation of graphical objects is done directly using the mouse, the scripts of objects can be tried directly in the context of the particular objects, and workspaces are used to manipulate objects with ad-hoc code snippets.
composition and other manipulation of graphical objects is done directly using the mouse, the scripts of objects can be tried directly in the context of the particular objects, and workspaces are used to manipulate objects with ad-hoc code snippets.
% ("what kind of changes?")

% Problem
however, such changes to objects can turn out not to be improvements. 
accidental changes, accidentally changing the position of a graphical object, or accidentally connecting the wrong objects graphically.
changes to the style of an object, color, size of borders, only to later-on realize or decide that the previous version was more appealing.
changes to the behavior, thereby introducing defects to the program, or accidentally decreasing the performance..
% ("what can go wrong?” / recovery needs)

so, when changes unexpectedly do not improve the system, the programmer needs to undo them manually.
Lively does not provide an undo for changes to objects that compares to the undo for changes to text other programming systems provide.
% So what?
This is especially at odds with Lively's support for trying ideas immediately.
Developers are able to make changes directly and receive immediate feedback, but do not get support when those changes turn out to be inappropriate.

When previous state has to be recovered, try to manually reset the state, using the same tools changes were made with, to how it previously was.
Resetting state manually requires her to comprehend all changes, to remember previous states, and to actually re-establish those---all while the changes might involve multiple properties of multiple objects from multiple different developer actions.

lively also allows to commit versions of objects.
in case she previously made a snapshot, she can load an earlier version of an object.
when an applicable commit exists, she could re-establish a preserved version.
Depending on how far such a version then is from the actually desired state, she might still have to make changes towards her target.
To keep the effort required to re-establish any previous state in this way low, she could preserve many versions.
% For example, she could preserve a version before for every manipulating action.
However, this requires her to make many commits---commits not to share and document her work, but to protect it against changes that unexpectedly turn out to be mistakes---and this would also be effort---especially when she still wants preserved versions to be usable and documented, requiring each preserved state to be tested and accompanied by a helpful description.

Both of these approaches require the programmer to manually re-set the changed state or to take explicit precautionary actions.



a typical approach for implementing undo.. command pattern~\cite{GammaHelmJohnsonVlissides95} to record all actions made by developers and provide rollbacks for each of those. This is, however, unpractical, given that developers can write and evaluate arbitrary code to manipulate objects directly. Further, even the discrete set of manipulations programmers can do with existing tools would require a rather comprehensive set of application-specific rollbacks, while developers would also have to implement new rollbacks for each newly implemented kind of direct manipulation.

a more recent approach to .. side-effects .. Worlds~\cite{Warth2011Wor}, a language construct for controlling the scope of side-effects. Worlds allow to capture the side-effects of statements into different worlds. These worlds can be used to run code with these changes. Developers could, conceivably, execute each of their actions in separate worlds and, subsequentely, when necessary, discard worlds to use previous ones instead. Worlds as such, though, would require developers to explicitly create and discard worlds. Therefore, worlds would still require the programmer to explicitly take precautionary actions for potentially necessary recovery, just like version control systems do. In addition, the respective implementation of Worlds is currently not yet practical. It, for example, prevents garbage collection.

Both the command pattern and Worlds still require developers to prepare for negative outcomes explicitly.
In contrast, CoExist~\cite{Steinert2012COE} provides support for undoing changes without requiring developers to take precautionary actions beforehand.
CoExist records versions for changes automatically and, thereby, provides a fine-grained history of development states.
Each change to source code yields a version that programmers can see diff views, test results, and screenshots to, and programmers can also re-establish all these versions. 
% Developers can re-establish versions conveniently and without making either many commits or cautious planning or undoing changes manually.
CoExist, though, is currently only available for Squeak/Smalltalk, not for Lively, and recognizes only changes made to the source code of classes.

% Solution
For similar recovery support in programming systems that allow to develop objects directly, we propose object versioning, to be able to preserve and re-establish versions of the programming runtime.
In particular, we propose an approach based on preserving multiple versions of objects and using alternative, version-aware references to objects.
Versions of objects are just objects, in the simplest case just copies, and are part of the application memory.
The version-aware references are references that know available versions of objects and resolve transparently to a particular version among those.
To not only have a single object be as it was at a particular moment, but instead all objects of the system, versions of all objects are preserved together, and the references resolve to corresponding versions accordingly.
So, to preserve a particular state of the system, the state of all objects is preserved, though possibly incrementally, on writes and only for objects that actually change.
Similarly, to which versions the version-aware references resolve is changed for all objects simultaneously, but this can also be done without significantly interrupting the system.
That is, the references can decide dynamically to which versions they resolve instead of being hard-wired to specific versions.
In result, object graphs connected by version-aware references can be resolved transitively as the system was at a particular point.

As concrete solution for Lively, we propose to implement version-aware references in JavaScript on the level of the language: through proxies and source transformations and without requiring adaptions to execution engines.
Proxies implement version-aware references.
They stand in for references: conventional references point to them and they delegate all object access--all kinds of reads and writes--to one of many versions of the object they stand in for.
A combination of proxy behavior and source transformation then allows to introduce and use these proxies consistently for all objects.

We propose this approach to object versioning for Lively with the intention to provide CoExist-like recovery support, including continuous versioning.
Therefore, the approach needs to support fine-grained histories of development states---many, but still particular versions of the entire runtime that can correspond to developer actions and can be re-established quickly.
It should also allow to enhance preserved development states with further information as, for example, test results, screenshots, and diffs.
That is, in the future, we want to build upon the proposed solution and support developers in efficiently recovering state from continuously preserved, fine-grained histories of development sessions.\\

% Contributions
The contributions of this thesis are as follows:
\begin{itemize}
    \item An approach to object versioning for systems like Lively based on alternative, version-aware references that transparently delegate to one of multiple versions of each object (Section~\ref{sec:APPROACH:1}).
    \item A concrete, language-level solution that provides the proposed version-aware references through proxies and source transformations for Lively (Section~\ref{sec:APPROACH:2}).
    \item An implementation of the concrete solution in JavaScript that can be used to preserve and re-establish development states in Lively (Section~\ref{chapter:IMPLEMENTATION}).\\
\end{itemize}

The remainder of this thesis is organized as follows. 
Chapter~\ref{chapter:BACKGROUND} illustrates the recovery needs developers have when they directly develop objects in programming systems.
Chapter~\ref{chapter:APPROACH} introduces our approach to object versioning and describes how proxies can be used for concrete solutions.
Chapter~\ref{chapter:IMPLEMENTATION} describes our implementation for the Lively Kernel, which Chapter~\ref{chapter:DISCUSSION} then discusses in terms of functionality and practicability.
Chapter~\ref{chapter:RELATED_WORK} compares our solution to related work.
Chapter~\ref{chapter:RELATED_WORK} presents future work, while Chapter~\ref{chapter:RELATED_WORK} concludes this thesis.
