% I. Background and context (problem area and motivation) 
% II. However (problem description)
% III. So what? (problem dimension) 
% IV. Deficiencies with previous approaches
% IV. Solution

\chapter{Introduction} \label{chapter:INTRODUCTION}

% Background
Programming systems like the Lively Kernel~\cite{Ingalls2008LKS,Krahn2009LWD}, also known as just \emph{Lively}, allow to directly change objects.
In contrast to many other object-oriented systems, in which programmers develop the source code of classes, Lively provides tools to directly manipulate the styles, the composition, and the scripts of particular objects.
Lively also encourages programmers to evaluate scripts directly to change objects or to test functionality.
The results of such development is the state of the objects, not abstract source code describing objects.

% Problem
But Lively currently does not provide undo for changes to objects on the level other programming systems provide undo for changes to text.
When changes turn out to be inappropriate, the programmer needs to undo them manually or, in case she previously made a snapshot, load an earlier version of an object.

% So what?
Both of these approaches require the programmer to do the work: either she has to see and undo all changes, which might involve many properties of many objects when, for example, the changes where introduced by evaluating a code snippet, or she has to make many snapshots of objects---not to share and document her work, but to protect it against changes that unexpectedly turn out to be mistakes.
The high effort of recovering from mistakes is especially at odds with Lively's encouragement to try ideas immediately: development happens at runtime, composition and other manipulation of graphical objects is done directly using the mouse, the scripts of objects can be evaluated directly in the context of the particular objects, and workspaces are used to manipulate objects with ad-hoc code snippets.
In short, developers are encouraged to change the state, but do not get much support when that unexpectedly does not improve the state.

% Previous / alternative approaches
Different approaches provide support for undoing changes made to the state of objects:
\begin{itemize}
    \item Lively could implement the command pattern~\cite{GammaHelmJohnsonVlissides95} to record all actions made by developers and provide rollbacks for each of those. This is, however, unpractical, given that developers can write and evaluate arbitrary code to manipulate objects directly, and even the discrete set of manipulations programmers can do with special-purpose tools would require a rather comprehensive implementation of the pattern.
    \item Programmers could use Worlds~\cite{Warth2011Wor}, a language construct for controlling the scope side-effects, to capture the effects of their actions into different worlds. Worlds as such, though, would require developers to explicitly create worlds before their changes and discard worlds when changes turn out be mistakes. Therefore, worlds would require the programmer to do take precautionary actions for convenient recovery support, just like version control systems do. In addition, the respective implementation of Worlds is not practical. It, for example, currently prevents garbage collection.
\end{itemize}

Another approach, called CoExist~\cite{Steinert2012COE}, provides support for undoing changes made to the source code of classes, and does this without requiring developers to take precautionary actions.
CoExist records versions for each change automatically and, thus, provides a fine-grained history of development states.
Besides diffs, CoExist also provides test results and screenshots to help programmers find the version they want to recover.
In result, developers are not required to make commits to be able to recover without manually undoing all changes.
CoExist, though, is currently only available for Squeak/Smalltalk, not for Lively, and recognizes only changes made to the source code of classes.

% Solution
For similar recovery support, we propose to implement object versioning in Lively: to be able to preserve and re-establish versions of the live programming system.
In particular, we propose an approach based on saving versions of objects and using alternative, version-aware references to objects.
Versions of objects are just objects, for example plain copies, and also part of the application memory.
The version-aware references are references that know available versions of objects and resolve to a particular version among those transparently.
To not only have a single object be as it was at a particular moment, but instead all objects of the system, corresponding versions of all objects need to be preserved together, and references need to resolve to corresponding versions accordingly.
So, to preserve a particular state of the system, the state of all objects is preserved, possibly incrementally, on writes and only for objects that actually change.
To which versions the version-aware references then resolve is changed simultaneously for all, also possibly without interrupting the system completely, through having the references decide dynamically to which version they resolve.
This way, multiple version-aware references can be resolved transitively to the state as it was at one point.

As concrete solution for Lively, we propose to implement version-aware references in JavaScript on the level of the language: through proxies and source transformations, without requiring adaptions to execution engines.
The proxies implement version-aware references.
That is, the proxies stand in for references: conventional references point to them and they delegate all object access--all kinds of reads and writes--to one among many versions of the object they stand for.
A combination of proxy behavior and source transformation then allows to introduce and use proxies consistently for all objects.

We propose this object versioning for Lively with the intention to provide CoExist-like recovery support, including continuous versioning.
Therefore, the approach should support fine-grained histories of development states---many, but still particular versions of the entire runtime that can correspond to developer actions and can be re-established quickly.
It should also allow to enhance preserved development states with further information as, for example, test results, screenshots, and diffs.
That is, in the future, we want to build upon the proposed solution and support developers in efficiently finding and recovering state from continuously preserved, fine-grained histories of development sessions.\\

% Contributions
The contributions of this thesis are as follows:
\begin{itemize}
    \item idea - object versioning: version-aware references (Section~\ref{sec:APPROACH:1}).
    \item approach for implementing version-aware with proxies and source transformations for Lively (Section~\ref{sec:APPROACH:2}).
    \item implementation in JavaScript, using EcmaScript 6 Direct Proxies (Section~\ref{chapter:IMPLEMENTATION}).\\
\end{itemize}

The remainder of this thesis is organized as follows. Section \ref{chapter:APPROACH} introduces our approach...\\
