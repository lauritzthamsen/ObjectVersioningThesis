% I. Background and context (problem area and motivation) 
% II. However (problem description)
% III. So what? (problem dimension) 
% IV. Deficiencies with previous approaches
% IV. Solution

\chapter{Introduction} \label{chapter:INTRODUCTION}

% Background
Programming systems like the Lively Kernel~\cite{Ingalls2008LKS,Krahn2009LWD}, also known as just Lively, allow to directly change objects.
In contrast to many other object-oriented systems, in which programmers develop the source code of classes, Lively provides tools to directly manipulate the styles, the composition, and the scripts of particular objects.
Lively also encourages programmers to evaluate scripts directly to change objects or to test functionality.
The results of such development is the state of the objects, not abstract source code describing objects.

% Problem
But Lively currently does not provide undo for changes to objects on the level other programming systems provide undo for changes to text.
When changes turn out to be inappropriate, the programmer needs to undo them manually or, in case she previously made a snapshot, load an earlier version of an object.

% So what?
Both of these approaches require the programmer to do the work: either she has to see and undo all changes, which might involve many properties of many objects when, for example, the changes where introduced by evaluating a code snippet, or she has to make many snapshots of objects---not to share and document her work, but to protect it against changes that unexpectedly turn out to be mistakes.
The high effort of recovering from mistakes is especially at odds with Lively's encouragement to try ideas immediately: development happens at runtime, composition and other manipulation of graphical objects is done directly using the mouse, the scripts of objects can be evaluated directly in the context of the particular objects, and workspaces are used to manipulate objects with ad-hoc code snippets.
In short, developers are encouraged to change the state, but do not get much support when that unexpectedly does not improve the state.

% Previous / alternative approaches
Different approaches provide support for undoing changes made to the state of objects:
\begin{itemize}
    \item Lively could implement the command pattern~\cite{GammaHelmJohnsonVlissides95} to record all actions made by developers and provide rollbacks for each of those. This is, however, unpractical, given that developers can write and evaluate arbitrary code to manipulate objects directly, and even the discrete set of manipulations programmers can do with special-purpose tools would require a rather comprehensive implementation of the pattern.
    \item Programmers could use Worlds~\cite{Warth2011Wor}, a language construct for controlling the scope side-effects, to capture the effects of their actions into different worlds. Worlds as such, though, would require developers to explicitly create worlds before their changes and discard worlds when changes turn out be mistakes. Therefore, worlds would require the programmer to do take precautionary actions for convenient recovery support, just like version control systems do. In addition, the respective implementation of Worlds is not practical. It, for example, currently prevents garbage collection.
\end{itemize}

Another approach, called CoExist~\cite{Steinert2012COE}, provides support for undoing changes made to the source code of classes, and does this without requiring developers to take precautionary actions.
CoExist records versions for each change automatically and, thus, provides a fine-grained history of development states.
Besides diffs, CoExist also provides test results and screenshots to help programmers find the version they want to recover.
In result, developers are not required to make commits to be able to recover without manually undoing all changes.
CoExist, though, is currently only available for Squeak/Smalltalk, not for Lively, and recognizes only changes made to the source code of classes.

% Solution
For similar recovery support in Lively, we propose Object Versioning, an approach for preserving and re-establishing versions of the runtime of systems like Lively.
Object Versioning saves particular versions of objects and uses alternative, version-aware references between all objects.
The version-aware references then delegate object access---all kinds of reads and writes---to a particular version of an object.
To which version the references delegate can be changed for all version-aware references system-wide for all references.
Similarly, demanding new versions of all objects is also done globally, but happens incrementally on writes, to not stop the environment completely for new versions.
This way, multiple version-aware references can be resolved transitively, following them as they were in a particular state of the runtime.

We propose this approach for Lively with the intention to provide CoExist-like recovery support through continuous versioning.
That is, the approach should allow fine-grained histories of development states---many, but still particular versions of the entire runtime that can correspond to developer actions and can be re-established quickly.
It should also allow to enhance versions of the runtime with further helpful information as, for example, test results, screenshots, and diffs. \\

% Contributions
The contributions of this thesis are as follows: \\
% \begin{itemize}
%     \item ...
% \end{itemize}

The remainder of this thesis is organized as follows. Section \ref{sec:APPROACH} introduces our approach... \\
