% I. Background and context (problem area and motivation) 
% II. However (problem description)
% III. So what? (problem dimension) 
% IV. Deficiencies with previous approaches
% IV. Solution

\chapter{Introduction} \label{chapter:INTRODUCTION}

% Background
Programming systems such as Squeak/Smalltalk~\cite{GoldbergRobson83} and REPLs for LISP or Python allow to adapt and develop programs while those run.
Changes to programs in such environments are effective immediately and programmers can often see or test right away what differences their actions make.
Thus, these systems provide immediate feedback to programmers.
A subset of such systems, which includes, for example, Self~\cite{Ungar1987SPS,Ungar2007SEL} and the Lively Kernel~\cite{Ingalls2008LKS,Krahn2009LWD}, are those built around prototype-based object-oriented languages, in which programmers create applications using objects and without having to define classes first.
In these systems, programmers can inspect and change the state of objects at runtime and can add and modify object-specific behavior.
The results of such development are actual objects, not source code that only abstractly describes potential objects.

The Lively Kernel was designed to support this kind of development and focuses, hereby, on graphical objects.
For this, the Lively Kernel provides tools to directly manipulate the style, the composition, and the scripts of graphical objects.
For example, programmers can change positions and the composition directly using the mouse.
They can edit and try methods directly in the context of graphical objects, or use temporary workspaces to manipulate one or many objects programmatically.
For example, to add new functionality to a graphical application, a programmer might copy an existing button object and then directly modify the newly button object: move the new button to a sensible position, resize it slightly, set a new label, and add a script to be executed on each mouse click.
The programmer makes all these changes directly to one button object and, for example, how the button fits into the application's interface is visible at all time, while clicking the button allows to directly test its functionality.
This way, the Lively Kernel often allows for fast feedback, especially during the development of graphical applications.

% Problem
Changes programmers make to objects---either using specific tools or through executing code---can, however, also turn out not to be improvements and still permanently affect objects.
Programmers can, for example, accidentally change the positions, accidentally connect the wrong objects when manipulating applications with mouse interactions, or make a mistake in a workspace code snippet that then manipulates many objects differently than intented.
Similarly, programmers might learn in hindsight that making a promising change to an object's scripts actually introduced an error or impacts the application's performance.
Less accidental but still problematic, they might try a couple of different alternatives as, for example, different color schemes and graphical layouts, only to realize later that an earlier state was most appealing and should thus be re-established.
Other potentially inappropriate changes might be introduced when code is evaluated to understand or test behavior, not to permanently change state.

% So what?
When changes, however, do turn out to be innapropriate, programmers often need to undo them manually or need to have prepared for potential negative outcomes in advance.
That is, the Lively Kernel does not provide an undo for changes to objects, which is especially at odds with the Lively Kernel's support for trying ideas right away: Developers are able to make changes directly and frequently receive immediate feedback, but do not get support when changes turn out to be inappropriate.
So, when programmers want to recover a previous development state, they often need to manually reset the state to how it previously was---often using the same tools the changes were initially made with and potentially involving multiple properties of multiple objects changed by multiple developer actions.

The Lively Kernel provides tools to commit and load versions of objects.
In case such commits exist, programmers can load earlier versions of objects to re-establish previous states.
Nevertheless, depending on how far such a commited version is from the actually desired state, manual changes might still be necessary.
Thus, to keep the effort required to re-establish \emph{any} previous state low, programmers would need to commit many versions.
However, these commits would partly be made only to preserve intermediate development states, not to share and document work results but to protect against changes that unexpectedly turn out to be mistakes.
The commits would further also require significant effort, especially when the preserved versions should be usable and documented, requiring states to be either tested and augmented with useful descriptions right away, or else requiring developers to actively clean up repository histories regularly.\\
\emph{In summary}, recovering previous states of objects in the Lively Kernel is currently a significant effort for programmers as they either have to manually re-set changed state or to take significant precautionary actions.\\

A typical approach to implementing multi-level undo for the changes to state of applications is the Command pattern~\cite{GammaHelmJohnsonVlissides95}.
The command pattern packages changes into actions.
It can then record actions and, when each action has been provided with an undo counterpart, subsequentely undo them.
This, however, requires developers to implement specific undos for all possible actions, which even for just the existing tools to manipulate objects in the Lively Kernel would result in a rather comprehensive implementation and which would of course also require developers to accompany each newly implemented manipulation tool with undos.  
Further, this approach is entirely unpractical for undoing the effects of evaluating arbitrary code snippets as, for example, regularly done in the Lively Kernel's workspaces.

Worlds~\cite{Warth2011Wor} is a recent and more generic approach using a language construct for controlling the scope of side-effects from arbitrary code.
It allows to capture the side-effects of statements into different \emph{worlds}.
These worlds can be used to run code with particular sets of changes being effective.
Developers could, thus, execute all their actions in separate worlds and discard those worlds when necessary to return to previous ones.
Worlds as such, though, would require developers to explicitly create as well as potentially merge or discard worlds, and, therefore, still needs the programmer to explicitly take precautionary actions, similar to version control systems.
In addition, the implementation of Worlds for and in JavaScript is not yet practical as it, for example, currently prevents garbage collection.

In contrast to these approaches, CoExist~\cite{Steinert2012COE} provides automatic recovery support, without requiring developers to take any precautionary actions beforehand.
For this, CoExist automatically records versions for every change and, thereby, provides a fine-grained history of intermediate development states.
To each preserved version programmers can also see diff views, screenshots, and test results.
Programmers can review the changes chronological, examine the impact each change had, and re-establish previous development states again.
However, CoExist currently recognizes only changes made to the source code of classes and does not preserve the state of objects.

% Solution
This thesis proposes to version the entire state of programming runtimes as basis for automatic recovery support in systems like the Lively Kernel.
In particular, this thesis introduces an approach to preserving and managing versions of all objects, which make up different runtime states, using alternative, \emph{version-aware} references.
Version-aware references are alternative references in that they can refer to multiple versions of objects, but always resolve transparently to one particular version among those.
Versions of objects are preserved together, so that the version-aware references can be resolved transitively to state as it was at a particular moment.
For this to be practical, versions of objects can be kept in application memory and the state of all objects can be preserved incrementally, on writes and only for objects that actually change.
Similarly, to which versions the version-aware references resolve can also be changed without significantly interrupting program execution:
The version-aware references can decide dynamically to which versions they resolve instead of being hard-wired to specific versions.

We implemented version-aware references for the Lively Kernel in JavaScript, on the level of the language using proxies and source transformations and, thus, without requiring adaptions to established execution engines.
Proxies implement version-aware references.
They stand in for references: conventional references point to them and they delegate all object access--all kinds of read and write operations--transparently to one particular version of the object they can stand in for.
A combination of proxy behavior and source transformation then allows to introduce and use these proxies consistently for all objects, in order to version the entire runtime state as is necessary for completely generic recovery support.

We designed and implemented this approach to object versioning for the Lively Kernel with the intention to provide CoExist-like recovery support, including continuous versioning, in the future.
Therefore, this approach supports fine-grained histories of development states---many, but still particular versions of the entire runtime that can correspond to developer actions and can be re-established quickly.
It also allows to easily enhance preserved development states with further information as, for example, test results, screenshots, and diffs.
That is, in the future, we want to build upon the presented solution and support developers in efficiently recovering state from continuously preserved, fine-grained histories of development sessions.

\section{Contributions}

The goal of this work is to provide a basis for automatic recovery support for the Lively Kernel.
To that effect, the main contributions of this thesis are the following:

\begin{itemize}
    \item An approach to object versioning for systems like the Lively Kernel based on alternative, version-aware references that transparently delegate to one of multiple versions of an object (Section~\ref{sec:APPROACH:1}).
    \item A concrete, language-level solution that provides the proposed version-aware references through proxies and source transformations for the Lively Kernel (Section~\ref{sec:APPROACH:2}).
    \item An implementation of the concrete solution in JavaScript that can be used to effectively preserve and re-establish development states in the Lively Kernel (Section~\ref{chapter:IMPLEMENTATION}).
\end{itemize}


\section{Thesis Structure}

The remainder of this thesis is organized as follows. 
Chapter~\ref{chapter:BACKGROUND} describes prototype-based programming systems, CoExist, and the Lively Kernel.
Chapter~\ref{chapter:MOTIVATION} illustrates how developers directly manipulate objects in the Lively Kernel and also exemplifies characteristic recovery needs associated with this kind of development.
Chapter~\ref{chapter:APPROACH} introduces our approach to object versioning and describes how proxies can be used for concrete solutions.
Chapter~\ref{chapter:IMPLEMENTATION} presents our implementation for the Lively Kernel, which Chapter~\ref{chapter:EVALUATION} then evaluates in terms of functionality and practicability.
Chapter~\ref{chapter:RELATED_WORK} compares our solution to related work.
Chapter~\ref{chapter:FUTURE_WORK} presents future work, while Chapter~\ref{chapter:CONCLUSION} concludes this thesis.
