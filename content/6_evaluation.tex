\chapter{Evaluation} \label{chapter:EVALUATION}

We evaluated our implementation of version-aware references in terms of functionality and practicability, as presented and discussed in this chapter.

Regarding functionality, we evaluated whether our proxy-based version-aware references behave like particular versions and whether they allow to preserve and re-establish versions of the development state of the Lively Kernel.

Regarding practicability, we evaluated the impact of proxy-based version-aware references on both memory consumption and execution speed.

For the tests, we used a standard benchmark suite and the Lively Kernel.


\section{Test Setup}

We tested our implementation with a standard JavaScript benchmark suite, the Lively Kernel, and a particular machine configuration, as described in this section.

\subsection{The Octane JavaScript Benchmark Suite}

% what?
We used the \emph{Octance} benchmark suite\footnote{\url{http://code.google.com/p/octane-benchmark/}, accessed February 3, 2014, at version 26} to test both the behavior and performance overhead of our alternative references.
Octane is a general JavaScript benchmark suite that consists of eight benchmarks.
It does not test JavaScript's language features systematically, but is a suite of real programs such as the \emph{DeltaBlue}\cite{FreemanBenson1990ICS} constraint solver.
These JavaScript programs make, however, use of many important language features, including primitive data types, operators, built-in functions, functions, objects, and prototypical inheritance.
Octane is also used in measuring the performance of \emph{v8}, the engine used by both the Chrome browser and Node.js, and is even part of v8's official source code repository\footnote{\url{http://v8.googlecode.com/svn/}, accessed April 23, 2014, at revision 20901}.

% why?
We decided to use the Octane suite for two reasons.
First, it covers many JavaScript language features and seems to be a benchmark suite that is widely in use.
Second, it is used particularly by the Chrome browser's JavaScript engine and Chrome is also the browser we used for developing and testing our implementation.


\subsection{The Lively Kernel System}

% what?
We continuously tested our system with the Lively Kernel.
We integrated our approach with version 2.1.3 of the Lively Kernel and, in particular, used the commit ba726ddca08df66b775e904366cdcbd76c4920f6\footnote{\url{http://github.com/LivelyKernel/LivelyKernel/commits/ba726ddca08df66b775e904366cdcbd76c4920f6}, accessed February 17, 2014} as starting point for our changes.
The version we used for all experiments described in this section is fc6f3b7e7e75cf3f866a8e5eb5899d65a5530654\footnote{\url{http://github.com/LivelyKernel/LivelyKernel/commits/fc6f3b7e7e75cf3f866a8e5eb5899d65a5530654}, accessed February 17, 2014}.
This version of the Lively Kernel can transform most of the Lively Kernel's code to insert proxies for mutable objects.
In particular, the versioning system is loaded right after loading Lively Kernel's module system.
Thus, enabling the versioning system excludes the Lively Kernel's extensions to the built-in JavaScript types, its bootstrap logic, and its module system, but includes everything loaded thereafter, including all modules and classes of the Lively Kernel.

% why?
We tested our implementation with the Lively Kernel for multiple reasons.
First, the Lively Kernel is a large JavaScript application that makes use of many features of both the JavaScript language but also the browser as particular host environment.
That is, it makes use of not only most of the features described in the language specification, including the language's standard library, but also much of the additional built-in functionality of the browser, which, for example, includes the built-in functions to manipulate the HTML document.
Second, the main goal of the presented work is to provide object versioning for the Lively Kernel.
Thus, we are particularly interested in evaluating our implementation with the Lively Kernel.


\subsection{Test Machine Configuration}

% what?
All tests and measurements were done on a Macbook Air with an 2 GHz Intel Core i7 and 8 GB main memory, using Mac OS X 10.9.1, and the most recent stable release of the Chrome browser on February 18, 2014, which was version 32.0.1700.107.

The presented measurement results were averaged over five runs.

% why?
We used Chrome for all experiments as the Lively Kernel currently works best in Chrome.







\section{Functionality: Versions of the Lively Kernel Runtime} \label{sec:DISCUSSION:1}

We tested whether the version-aware references forward to particular versions correctly both with benchmarks and with the Lively Kernel, as described in this section, and did this continuously during the implementation of our approach.

\subsection{Testing with Benchmarks}

We ran the Octane benchmark suite to test the functionality of our implementation.

\paragraph{Method}
% what was done?
We transformed the Octane benchmarks with our source transformations, executed the resulting code, and then checked for JavaScript errors and compared the results of running the transformed benchmarks to their usual results.\\
% why / to test what?
We did this for to test two aspects.
First, to test whether our source transformations yield syntactically correct JavaScript code for the benchmarks.
Second, to test whether the proxy-based implementation of version-aware references, inserted by the source transformations, allows to run the benchmarks without errors and with the same results as when the benchmarks are executed without our implementation.


\paragraph{Results}
All benchmarks in this suite run without errors and return the same results as when executed without any source transformations.
That is, at least for these tests, our source transformations produce working source code and our proxy-based version-aware references behave as the object versions they stand-in for.
The benchmarks and, in particular, the \emph{DeltaBlue} benchmark revealed a problem with using proxies as prototypes of objects, which we reported to the \emph{harmony-reflect} repository\footnote{\url{http://github.com/tvcutsem/harmony-reflect/issues/18}, accessed April 23, 2014} and which turned out to be an issue with the \emph{v8} JavaScript engine itself\footnote{\url{http://code.google.com/p/v8/issues/detail?id=2804}, accessed April 23, 2014}.
We virtualized the prototype relation among proxies as workaround for this problem in our implementation, but the issue was subsequentely fixed, rendering the implemented workaround redundant.

\paragraph{Discussion}
The proxies, which implement version-aware references, behave like the respective versions of objects in the situations exhibited in the benchmarks.
While these benchmarks do not test JavaScript's features systematically, they cover a range of language features.


\subsection{Testing with the Lively Kernel}

We tested whether the Lively Kernel loads and works as expected when our version-aware references are used.

\paragraph{Method}
% what was done?
We transformed the JavaScript modules of the Lively Kernel at load-time to test whether it loads and works as expected with our versioning system.
We further tested whether the version-aware references and the linear global undo/redo allow to preserve and re-establish versions of the Lively Kernel's JavaScript runtime in practice.
Here, we tried multiple simple example scenarios, including to undo changes to the state and behavior of basic morphs, to morph compositions, and to the state of more complicated graphical applications as, for example, text editors and developer tools.\\
% why / to test what?
With this, we tested that the source transformations yield valid JavaScript code for the modules of the Lively Kernel, that the version-aware references delegate correctly to the versions of objects they stand-in for in Lively, and that the version-aware references are used consistently for all mutable objects.


\paragraph{Results}
The Lively Kernel loads when all of its modules are transformed to use version-aware references.
Further, most of its basic functionality works as expected and we were able to preserve and re-establish runtime states of multiple examples.
However, not all functionality works as expected and we were, thus, also not able to re-establish all preserved states. 
This way, we also learned about the issues of the current state of ECMAScript 6 Direct Proxies in Chrome and implemented the workarounds described in Section~\ref{sec:IMPLEMENTATION:4}.

\paragraph{Discussion}
While most of the tested functionality of the the Lively Kernel---including the entire bootstrap process, rendering graphical objects, loading parts from the Lively Kernel's Parts Bin, and using the Lively Kernel's halo controls---work as expected with version-aware references, certain functionality of the Lively Kernel is not yet working correctly or even yields errors.
The remaining issues here are expected to be problems related to built-in JavaScript functions that do not handle proxies correctly.
Our implementation already unwraps proxies for many built-in functions, as explained in \ref{sec:IMPLEMENTATION:4}, but the configuration appears to currently not cover all problematic built-in functions, yet.
However, the used proxies are still an experimental JavaScript feature in Chrome, not yet fully supported, and we expect these issues not to be problems anymore once the proxies get fully implemented by JavaScript engines.
Further, the current implementation already allows to use many features and re-establish many development states of the Lively Kernel.




\section{Practicability: Additonal Memory Consumption} \label{sec:DISCUSSION:2}

We measured the memory overhead of just the version-aware references, without preserving any version, and also present the memory used when multiple versions of a small example scenario are preserved.

\subsection{Memory Overhead for Version-aware References}

The version-aware references have an impact on memory consumption that has to be practical.

\paragraph{Method}
% what was done?
We measured the memory consumption of an empty Lively world when loaded with and without source transformations and, thus, version-aware references.
In this experiment, we did not preserve any versions of the development state.\\
% why / to test what? 
This way, we only measure the overhead of the proxy-based version-aware references themselves as each of those refers to only one version---the original objects, which are present both with version-aware references and without.
We decided to load an empty Lively Kernel world to measure the overhead in a minimal runtime, while expecting the overhead to grow linearly with the number of proxied objects.

\begin{figure}[h!]
    \centering
    \includegraphics[width=\textwidth]{figures/6_evaluation/1_memoryOverhead.pdf}
    \caption{Memory consumption when starting a Lively Kernel world with and without proxies.}
    \label{fig:MemoryOverheadForReferences}
\end{figure}

\paragraph{Results}
As shown in Figure~\ref{fig:MemoryOverheadForReferences}, loading an empty the Lively Kernel world requires three times more space with proxies than without proxies.

\paragraph{Discussion}
Even without preserving multiple versions of any object, the system requires more space when loaded with versioning proxies.
The system uses a proxy for each created mutable object and all references that would usually refer directly to the object refer to the proxy instead.
These proxies require additional space: Each proxy comprises of at least an internal proxy object, a proxy handler object that implements the proxy's behavior, and an ordinary JavaScript object as dictionary for all available versions of the object the proxy stands-in for.
The memory overhead increases linearly with the number of objects accessed through proxies.
While the system creates proxies for most objects, it does not use proxies for all objects.
In particular, it does not create proxies for objects present before our implementation of object versioning is loaded, including all objects used by the versioning implemenation itself.
We expect the number of objects that are excluded from versioning to be relatively stable, while all additional objects created at runtime will be accompanied by proxies.
Currently, the proxies are not optimized to consume as little space as possible.
Two improvements of the current implementation would be to not create a versions dictionary as long as a proxy stands-in for only one version and to have the proxy handlers of all our proxies share their behavior.
The memory overhead, however, does not appear to be problematic at the moment.


\subsection{Memory Usage for Preserving Versions}

Besides the memory required for the proxies, there is also memory required for preserving multiple versions of the runtime.
Although we expect the memory usage for versions to be highly dependent on the differences between preserved states, we still present a simple example scenario here.

\paragraph{Method}
% what?
To measure how much memory is required for preserving versions of the runtime state, we measured the memory consumed at three different moments in a simple scenario, which are highlighted as \circnum{1}, \circnum{2}, and \circnum{3} in Figure~\ref{fig:MemoryOverheadForVersions}.
The memory measured is not limited to the memory required for versions, but is instead the memory used by the entire JavaScript runtime.
In particular, we did the following:
\begin{enumerate}
    \item We measured the memory consumed for the state \circnum{1} and then commited the version of the runtime.
    \item We changed the state to be state \circnum{2}, measured the memory again, and commited that version.
    \item We changed the state to be state \circnum{3} and measured the memory again.
\end{enumerate}

\begin{figure}[h!]
    \centering
    \includegraphics[width=\textwidth]{figures/6_evaluation/2_memoryForVersions.pdf}
    \caption{Memory consumed by the same runtime at three different moments in time, after preserving the previous states.}
    \label{fig:MemoryOverheadForVersions}
\end{figure}

\paragraph{Results}
As shown in Figure~\ref{fig:MemoryOverheadForVersions}, the memory consumption is not very different for the three situations.
The second state required the most memory for the JavaScript runtime, while the memory consumption of the third state is in-between the first and the second.
That is, in this example, the space required for preserving the two states of the morphic objects is insignificant to the space already required for running a Lively Kernel world.

\paragraph{Discussion}
Our implementation does not copy all objects for each version, but only creates copies when objects subsequentely change, effectively storing only the differences between runtime versions.
Therefore, the memory required for preserving versions of the runtime depends on how objects change compared to the predecessor version.
Except for not visible objects created due to mouse interactions, the state \circnum{2} consists of the same objects as state \circnum{1}, but holds multiple versions of the state of the involed morphs and, therefore, the memory footprint increases, but only slightly.
The memory required for the entire JavaScript runtime---not only for preserving versions---does not always increase as there are also temporary objects that are not preserved with any version.
Such temporary objects include the state of JavaScript objects that represent HTML document elements.
These objects can be derived from preserved morph states and, thus, do not have to be preserved.
For this reason, it does not seem odd that state \circnum{3} requires less memory than state \circnum{2}, even though from the third state both previous states can be re-established.\\
\emph{In summary}, the memory overhead for preserving different versions of the runtime does not increase exactly linearly with the number of versions and does not only depend on how many objects are part of the versioned states, but instead highly depends on the differences between preserved versions.



\section{Practicability: Impact on Execution Speed} \label{sec:DISCUSSION:3}

We measured the overhead the proxies impose on the execution of benchmarks and certain functionality of the Lively Kernel.
A discussion of the results follows at the end of this section.


\subsection{Measuring Benchmarks}

The Octane benchmark suite shows how the proxies currently slow down a variety of different JavaScript programs, while two microbenchmarks show the specific cost of using the proxy-based version-aware references.

\subsubsection{Octane Benchmark Suite}

Measuring the Octane benchmark suite highlights how the execution of eight JavaScript programs is affected by the proxies.

\paragraph{Method}
We ran the Octane benchmarks\footnote{Note: We reduced the input size to the Splay benchmark by an order of magnitude to prevent the browser from prompting for user input during the benchmark's execution. The prompt is triggered due to the long time required to run the benchmark. It cannot be disabled and would influence the benchmark result.} with and without previous transformation of the benchmark code and, therefore, with or without version-aware references.
The source transformations for this were done separately and are not reflected in these results.

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{figures/6_evaluation/3_executionOverhead.pdf}
    \caption{Execution overhead for proxy-based version-aware references compared to ordinary JavaScript references.}
    \label{fig:ExecutionOverhead}
\end{figure}

\paragraph{Results}
Figure~\ref{fig:ExecutionOverhead} shows how much more time the benchmarks take when their source is transformed before execution and references are, therefore, version-aware.
Executing the benchmarks takes between 90 and 405 times longer with version-aware references than without.
On average the slowdown of a single benchmark is, thus, a 187.5 times.


\subsubsection{Microbenchmarks}

We implemented microbenchmarks to analyze the overhead the proxies impose on resolving references---the time proxies take to forward access to a particular version.

\paragraph{Method}
In the first setup, we resolved a reference between two objects a million times, where the reference is either an ordinary reference or a proxy-based version-aware reference.
In the second setup, we exchanged the proxy-based version-aware reference with a standard proxy without providing a handler object.
In this case the proxy falls back on the default proxy behavior, which is forwarding to a single target and which we regard as a minimal overhead for reasonable proxy behavior. 

\paragraph{Results}
In the first setup, the microbenchmark takes three orders of magnitude more time when using the version-aware references: instead of on average 10 milliseconds the test requires on average about 11000 milliseconds to finish.
In the second setup, the difference is an order of magnitude less: with a direct reference the benchmark still requires around 10 milliseconds, while the benchmark requires requires close to 2000 milliseconds with a proxy as connection between both objects.
That is, even the default proxy behavior slows down the microbenchmark close to 200 times.



\subsection{Measuring the Lively Kernel}

We measured the overhead of a few typical user interactions and also how much longer it takes to load a simple Lively Kernel world.

\subsubsection{Typical Lively Kernel Interactions}

As our goal is to provide recovery support for development in Lively Kernel, the impact on typical interactions is especially interesting as it directly experienced by developers.

\paragraph{Method}
% what?
We measured the overhead for typical user interactions in the Lively Kernel by comparing the time three interactions take when using proxies and when not using proxies, from the time of the user event until the single-threaded JavaScript engine becomes responsive again.
The three typical interaction we chose investigate are: bringing up the halo buttons on a particular morph, opening the world's menu, and opening the Lively Kernel's System Code Browser.\\
% why?
We chose these three interactions as they are expected to be among the more impacted interactions compared to, for example, interactions that are more browser-supported and less reliant on JavaScript execution such as dragging elements around the screen.
All three interaction trigger code from multiple different modules, including event handling code, rendering code, and tool-specific code.

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{figures/6_evaluation/4_LivelyInteractionsOverhead.pdf}
    \caption{Execution overhead for selected user interactions in the Lively Kernel.}
    \label{fig:LivelyInteractionsOverhead}
\end{figure}

\paragraph{Results}
Figure \ref{fig:LivelyInteractionsOverhead} shows the results, which are comparable for all three interactions.
Each of these interactions takes on average 43 times the time when triggered after the system's was loaded with proxies.



\subsubsection{Loading a World in the Lively Kernel}

Another performance-related question specific to the Lively Kernel is how long it takes to load a world.

\paragraph{Method}
We measured how long it takes to load a specific Lively Kernel world both with and without source transformations and, thus, proxies.
Loading a world includes requesting the required modules from the Lively Kernel's server, client-side code to resolve dependencies among modules, evaluating all loaded modules, and deserializing a the Lively Kernel world.
Additionally, in case version-aware references should be used, the sources of all modules also are transformed while loading a world.

\paragraph{Results}
The overhead of loading a world with object versioning is a factor of around eight for loading a world: instead of around 4 seconds, the user would have to wait around 32 seconds until the requested the Lively Kernel world reacts on user interactions.




\subsection{Discussion of the Execution Overhead}

The execution overhead of the current implementation of version-aware references does not appear practical.
The current implementation slows down the JavaScript execution considerably: 

\begin{itemize}
    \item the Octane benchmarks need two to three orders of magnitude more time to finish
    \item the examined user interactions in the Lively Kernel take two orders of magnitude more time
    \item direct comparisons of resolving version-aware references and direct references in a microbenchmark show a slowdown of four orders of magnitude
\end{itemize}

While object versioning could be used to provide the undo/redo of a specific application, it is primalary itented to support development and similar explorative tasks.
That could, conceivably, be an argument for providing object versioning only during development, not when programs are only in-use and should run at full speed.
However, besides having the disadvantage of introducing distinct usage modes, this still requires the version-aware references to resolve fast enough to not impede development significantly, which they currently do not yet do.

We gained the impression that only one order of magnitude is due to the specific proxy behavior, while most of the overhead can be ascribed to using the Direct Proxies as currently available in the Chrome browser.
The proxies are part of an ECMAScript specification that has not yet been finalized and completely implemented by the JavaScript engines.
As explained in Section~\ref{sec:IMPLEMENTATION:1}, the proxies are currently also implemented using a library that relies on an experimental implementation of a previous, deprecated draft of the proxy specification.

Similar behavior forwarding as provided by the proxy handlers could also be implemented in JavaScript, using source transformations and ordinary JavaScript functions.
Instead of using an actual proxy for an object, we could have references point to an ordinary JavaScript object and implement the handler behavior in an ordinary JavaScript function, to be used through further source transformations: instead of \lstinline{obj.prop} the system would execute code similar to \lstinline{get(obj, \"name\")}, where the \lstinline{obj} could still be only a stand-in for many different versions, while \lstinline{get} could implement the behavior previously implemented by respective the proxy trap.
Measuring the performance of such a simple indirection results in a much lower performance overhead for the previously described microbenchmark setup:
it only takes twice the time to read a property from a specific target with a \lstinline{get}-function when compared to reading a property directly.

All this---the experimental status of the proxy implementation, the high cost of proxies even when used with the default handler behavior, and the significantly lower overhead of a custom indirection based on ordinary JavaScript functions---suggest that the performance of the ECMAScript 6 Direct Proxies in Chrome might improve in the future.
At the same time, we might also decide to base our version-aware references on source transformations and custom indirections instead of proxies in the future.


% TODO: Summary? should we? then we'll also need summaries for chapter 3-5.. :-/

% \section{Summary}
% 
% \todosec{add a summary of this longlong chapter, which may read similar to what introduced this Chapter in the version I gave to Bastian}

% The experienced slow down does not depend as much on the number of preserved versions, but instead depends on how many version-aware references have to be resolved during the execution of particular code.

