\chapter{Summary} \label{chapter:SUMMARY}

% Approach
This work introduced an approach to preserving access to previous states of programming systems such as the Lively Kernel.
The approach is based on version-aware references.
These references manage different versions of objects transparently.
They resolve to one of multiple versions of objects and to which ones can be easily changed.
Thereby, different preserved states can be re-established.

We presented a design for our approach that uses proxies for version-aware references.
Instead of actually using alternative references, ordinary references refer to proxies and proxies forward access transparently to the right versions.
The design allows to implement version-aware references without any adaptions to existing execution engines---neither for alternative references nor for garbage collection of versions.\\
For each new object that is created, a proxy is created and returned instead of the object.
Thus, references to proxies are passed around and all access goes through the proxies.
Moreover, only the proxies refer to the versions of an object.
So, the versions of an object are reclaimed together with the object's proxy by the ordinary garbage collector.\\
Returning new proxies for new objects is achieved automatically using source transformations.
Programs are transformed when loaded and, thus, do not have to be adapted manually.

% Significance, Practical applications
We implemented our approach to object versioning in JavaScript for the Lively Kernel.
It enables programmers to commit and re-establish versions of the system.
For this, only a global version identifier has to be changed to switch versions.
The proxies then choose and create versions of objects accordingly when they intercept access.
This way, the costs for preserving and re-establishing versions is distributed accross object interactions and the implementation is optimized for preserving access to fine-grained histories.

We evaluated our implementation with benchmarks and the Lively Kernel.
The version-aware references behave correctly in the situations tested.
The memory overhead is reasonable.
The execution overhead is, however, not yet practical.
For example, the execution of eight JavaScript benchmarks takes currently three orders of magnitude more time with our version-aware references.

% Future work
In the future, the implementation could be improved by reducing the execution overhead.
In addition, the system should preserve relevant versions automatically and support developers in finding versions when recovery is necessary.

% Summary sentence
Nevertheless, the presented solution already enables programmers to preserve and re-establish versions of the Lively Kernel.
Programmers can commit versions of the system and, subsequentely, undo and redo changes made in-between those versions.
That is, with our solution, the Lively Kernel provides not only tools to making changes directly to objects, but also tools to recovering previous states when such changes turn out to be inappropriate.
