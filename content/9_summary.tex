\chapter{Summary} \label{chapter:SUMMARY}

% Approach
This work presented an approach to preserving access to previous states of programming systems such as the Lively Kernel.
The approach is based on alternative, version-aware references that transparently manage different versions of objects.
This version-aware references always refer dynamically to particular versions to consistute a system state.
To which version they refer can, however, easily be changed to allow to re-establish a different state of the system.

We presented a design for the approach that relies on proxies for version-aware references instead of on adapting existing execution engines.
Instead of actually prodiving alternative references, ordinary references refer to proxies and proxies forward access transparently to the right versions.
Transforming the sources before execution proxies allows to create and return proxies immediately when objects are created. 
This way, the references to proxies are passed around and all access goes through the proxies.
Also, only the proxies refer to the versions of an object and both are reclaimed together by the ordinary gargabe collector.
The design based on proxies allows to implement version-aware references without any adaptions to execution engines, while the source transformations make the necessary adaptions to programs automatically.

% Significance, Practical applications
We implemented and evaluated this approach to object versioning for the Lively Kernel and in JavaScript.
The implementation allows to preserve and re-establish versions of the running Lively Kernel.
That is, programmers can use the implementation to make commits of the system state and undo any changes subsequentely made to objects.

Our evaluation shows that the version-aware references behave correctly in the situations tested and that their memory overhead appears to be practical. The execution overhead, however, is not yet practical.
The execution of JavaScript benchmark programs takes three orders of magnitude more time than without our system.

% Future work
In the future, we want to make our system more practical.
For this, we want to improve the performance of our implementation.
In addition, the system should preserve versions automatically and support developers in finding versions when recovery is necessary.

% Summary sentence
Nevertheless, our solution already can preserve access to previous states of the Lively Kernel.



% Our approach for this is based on alternative, version-aware references that manage versions of objects transparently. That is, objects are referred to by references that dynamically and transparently choose one particular version of the objects as they were at a particular moment. When these references are then used for all mutable objects of a runtime, the entire runtime state can be preserved and re-established.
% 
% Our concrete solution for implementing this in JavaScript and for the Lively Kernel relies on proxies and source transformations. Using proxies and source transformations allows a language-level solution for alternative references. Ver- sions of objects are also just JavaScript objects and, thus, also in memory. The proxies, in this solution, also contain the versions of the object they stand-in for. This way, when a proxy, which stands in for all versions of conceptually one object, is no longer referred to from anywhere, all versions of an objects are reclaimed by the ordinary JavaScript gargage collector.



% We implemented version-aware references for our approach to object versioning in JavaScript using proxies and source transformations. This way, our prototype does not require changes to JavaScript engines, but only a certain JavaScript language feature. In particular, it requires the Direct Proxies1 as proposed with Version 6 of ECMAScript, the standard that JavaScript follows. These proxies can implement specific behavior to handle various kinds of access to them. In our implementation, these proxies are used to delegate all access to a particular version of the object they stand in for. To have these proxies intercept access to all mutable objects for which versions should be preserved, our prototype uses a combination of source transformations and proxy behavior. In particular, the moment mutable objects get created, proxies get created for the new objects and references to the proxies are returned instead of references to the actual objects. The proxies then preserve and choose versions of their object corresponding to a global version identifier. This version identifier effectively declares one particular state of the programming runtime, consisting of those versions of objects that are associated with that runtime state, to be read and written. Therefore, to change the entire runtime state as, for example, an undo and redo would require only the global version identifier needs to be changed.



% When programmers unexpectedly introduce problems to the functionality, per- formance, or design of their applications, they might want to recover a previous development state. In programming systems like Lively, where programmers often work at runtime on objects, a development state consists of the state of objects, which includes object-specific behavior. To be able to recover such a development state, comprehensive recovery support for Lively must, therefore, preserve versions of objects.
% 
% Our approach for this is based on alternative, version-aware references that manage versions of objects transparently. That is, objects are referred to by references that dynamically and transparently choose one particular version of the objects as they were at a particular moment. When these references are then used for all mutable objects of a runtime, the entire runtime state can be preserved and re-established.
% 
% Our concrete solution for implementing this in JavaScript and for the Lively Kernel relies on proxies and source transformations. Using proxies and source transformations allows a language-level solution for alternative references. Ver- sions of objects are also just JavaScript objects and, thus, also in memory. The proxies, in this solution, also contain the versions of the object they stand-in for. This way, when a proxy, which stands in for all versions of conceptually one object, is no longer referred to from anywhere, all versions of an objects are reclaimed by the ordinary JavaScript gargage collector.
