\chapter{Discussion} \label{sec:DISCUSSION}

Our JavaScript implementation seems functional, but not yet practical.

Correctly running JavaScript benchmarks and our target programming system, the Lively Kernel, attest the functionality of our JavaScript implementation.
The proxies, which implement version-aware references, behave like the respective version of an object in all situations tested by the benchmarks and the Lively Kernel.
Additionally, the linear global runtime versions exemplify how our approach and our JavaScript implementation allow to re-establish previous development states in Lively.
Therefore, all references to relevant objects are version-aware in all tested situations.

The memory overhead of our implementation appears to be practical, while the execution overhead of the current implementation does not.
The current execution overhead is in the range of three orders of magnitude for popular JavaScript benchmarks and typical user interactions in Lively.
Microbenchmarks comparing the version-aware references to direct references however even slow down four orders of magnitude.

In analyzing this overhead, we gained the impression that only one order of magnitude is due to the specific proxy behavior, while most of the overhead can be ascribed to the proxy implementation itself.
In fact, we experienced that a comparable indirection to the proxies can be implemented considerably faster with ordinary JavaScript.
This raises questions about the current state of the implementation of the proxies themselves, especially about interference with the v8's JIT compiler, and also indicates more practical implementation strategies.

The proxies show during debugging due to limitations of the proxy implementation.
However, the developer tools show the original source code, despite the implementation's transformations of the sources.



\section{Functionality: Undo and Redo for the Lively Kernel}

\begin{itemize}
    \item common JavaScript language benchmark suites: Octance\footnote{\url{http://code.google.com/p/octane-benchmark/},\goodbreak accessed February 3, 2014, at version 26} and The Computer Language Benchmarks Game\footnote{\url{http://benchmarksgame.alioth.debian.org/},\goodbreak accessed February 3, 2014}, javascript implementation\footnote{\url{http://github.com/kragen/shootout},\goodbreak accessed February 3, 2014, at version 71aa4ec4cd15940c59f1a1bb71ac1ff1572a55c2}
    \item starting and running the Lively Kernel with version-aware references, simple global undo / redo for lively
\end{itemize}



\section{Practicability: Impact on Performance}

memory overhead:
\begin{itemize}
    \item for the version-aware references for lively, measured (and explained… per proxy now...)
    \item something about how each new global version requires memory, but each depending on how big the changes are / or how much needs to be copied..
\end{itemize}


execution time overhead:
\begin{itemize}
    \item common JavaScript language benchmark suites – with vs. without proxies
    \item user interaction benchmarks – with vs. without proxies
\end{itemize}


analysis...
maybe some discussion of the execution overhead and numbers on the different layers of the layered implementation cost how much performance: versioning proxy handler > default ES 6 shim proxies > harmony proxies in Chrome..



\section{Usability: Impact on Debugging}

\begin{itemize}
    \item adds lots of ‘low-level’ frames, dev tools don’t handle proxies well (hovering, labels, stepping into), but we have at least source maps, so developers can debug the original code and not the result of our source transformation
\end{itemize}
