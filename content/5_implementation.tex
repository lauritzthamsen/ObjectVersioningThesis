\chapter{Implementation} \label{chapter:IMPLEMENTATION}

We implemented version-aware references for our approach to object versioning in JavaScript using proxies and source transformations.
This way, our prototype does not require changes to JavaScript engines, but only a certain JavaScript language feature.
In particular, it requires the Direct Proxies\footnote{\url{http://wiki.ecmascript.org/doku.php?id=harmony:direct_proxies}, accessed February 3rd, 2014} as proposed with Version 6 of ECMAScript, the standard that JavaScript follows.
These proxies can implement specific behavior to handle various kinds of access to them.
In our implementation, these proxies are used to delegate all access to a particular version of the object they stand in for.
To have these proxies intercept access to all mutable objects for which versions should be preserved, our prototype uses a combination of source transformations and proxy behavior.
In particular, the moment mutable objects get created, proxies get created for the new objects and references to the proxies are returned instead of references to the actual objects.
The proxies then preserve and choose versions of their object corresponding to a global version identifier.
This version identifier effectively declares one particular state of the programming runtime, consisting of those versions of objects that are associated with that runtime state, to be read and written.
Therefore, to change the entire runtime state as, for example, an undo and redo would require only the global version identifier needs to be changed.

% TODO CHAPTER STRUCTURE TODO

% proxy behavior: traps + forwarding
% selecting versions: currentVersion + global version identifier

% JS concurrency

% source transformations: basic cases + func exps vs. decls, accessor funcs

% workarounds / ES 6 issues: virtual object proxies + native code / built-in functions

% limitations / ES 6 implications: proxies have to be available, lots of low-level frames and dev tool issues



\section{ECMAScript 6 Proxies as Version-aware References} \label{sec:IMPLEMENTATION:1}

Our implementation of version-aware references is based on the ECMAScript 6 Direct Proxies.
While these are supposed to stand-in for particular objects, their \emph{targets}, they can also be used as fully virtual objects.
In our case, the proxies represent multiple different versions of an object and do not delegate to any of those by default.
Instead, they choose one of potentially many versions of an object to delegate to dynamically.
Further, the Direct Proxies in our implementation also stand-in transparently for the multiple versions of an object.
That is, the proxies always do behave---except for some specific introspection cases---as if they were a specific version of an object and programmers should not have to be aware about the versioning proxies.

The behavior of the proxies can be specified in \emph{Traps}, methods to specify how exactly specific access to the proxy should be handled, which are bundled in a \emph{Handler} object that is supplied when creating the proxies.
Our implementation of version-aware references using proxies is, thus, defined by our specific proxy handlers that provide the necessary delegation behavior through the traps.
Specific traps are called for specific access. 
For example, when \lstinline{person} is a proxy and \lstinline{person.age} is called, the \emph{get}-trap is called and receives \lstinline{target}, \lstinline{name}, and \lstinline{receiver} as arguments.
In our implementation, the \emph{target} parameter is irrelevant as we use proxies as virtual objects, not to be associated with any particular target object.
The other two parameters, however, are relevant and, for the given example, the \emph{name} would be the string \'age\' and \emph{receiver} would be the proxy for \emph{person} again.
Our proxy handler's \emph{get}-trap is implemented as indicated by the following code snippet, which is, however, simplified in that it leaves out much of the handling of special cases that are due to the shortcomings of the used implementation of Direct Proxies:

\todo{add a Figure: proxy and proxy-handler, with traps and a link to the versions of an object. maybe also in comparsion to an just an object or in context of another object's property (that refers to the proxy now)}

\iffalse
\begin{verbatim}\fi
\begin{code}{}{}
get: function(dummyTarget, name, receiver) {

    var version = this.currentVersion();
    
    // proxy meta information and other special cases..
    if (name === 'isProxy') {
    // ...
    if (name === 'proxyTarget') {
    // ...
    
    result = version[name];
    
    return this.ensureProxied(result);
}
\end{code}
\iffalse
\end{verbatim}\fi

First, the current version gets determined using the \lstinline{currentVersion()} function, which is explained in \ref{sec:IMPLEMENTATION:3}.
Then, multiple special cases are handled, including special properties to allow to determine whether a proxy, which otherwise behaves transparently, actually is a proxy or to allow to unwrap the current version from the proxy.
In the simple scenario that we are only reading a property named \lstinline{age} from an object \lstinline{person} all these special conditions fall through.
Instead, the trap reads the property from the current version and returns the result.
The result is passed to the \lstinline{ensureProxied()} function to make sure that mutable objects are proxied.
When a mutable object that is not wrapped in a proxy is passed to this function, the function returns a proxy instead.
This is necessary as, while application-specific objects properties are expected to be proxied, some built-in objects in JavaScript engines refer to their properties directly and not through proxies, but these properties might be required to be proxied to be versioned and to implement version-aware behavior.

\todo{add a figure / uml diagram that presents what is done in the get-trap}

Besides the \emph{get}-trap, our proxy handler similarly provides behavior for all other traps, which also delegate to the currently selected version of the object.
The following table \todo{table caption and refer its ref number} provides an overview over the implemented proxy traps:

\begin{table}[h]
\begin{tabular}{|l|l|r|}
\hline
get: function(target, name, receiver) \\ \hline
set: function(target, name, value, receiver) \\ \hline
apply: function(target, suppliedThisArg, suppliedArgs) \\ \hline
construct: function(target, args) \\ \hline
has: function(target, name) \\ \hline
hasOwn: function(target, name) \\ \hline
defineProperty: function(target, name, desc) \\ \hline
deleteProperty: function(target, name) \\ \hline
getOwnPropertyNames: function(target) \\ \hline
getPrototypeOf: function(target) \\ \hline
freeze: function(target) \\ \hline
seal: function(target) \\ \hline
preventExtensions: function(target) \\ \hline
isFrozen: function(target) \\ \hline
isSealed: function(target) \\ \hline
isExtensible: function(target) \\ \hline
enumerate: function(target) \\ \hline
keys: function(target) \\ \hline
\end{tabular}
\end{table}

All these traps fire either when the proxy is accessed with specific JavaScript operators or when it is passed to meta-programming facilities provided by built-in globals\footnote{\url{http://wiki.ecmascript.org/doku.php?id=harmony:direct_proxies\#api}, accessed March 5, 2014}.
For example, the \lstinline{preventExtensions}-trap fires when a proxy is passed to the built-in \lstinline{Object.preventExtensions()} function, which prevents new properties from subsequentely being added to an object.

The handler object is an ordinary JavaScript object and, thus, can hold arbitrary properties.
Besides providing the trap methods, our proxy handler objects also hold the versions of the represented object.
For this, the proxy handler uses an object as dictionary that associates version identifiers with the different versions of the object.
This version dictionary is used by the handler's \lstinline{currentVersion} function that decides which of the versions should currently be accessed.
Having the handler object hold all the versions of conceptionally one object also takes care of garbage collection.
When a proxy gets garbage collected, all versions get garbage collected as well.




\section{Runtime Versions for Global Undo and Redo} \label{sec:IMPLEMENTATION:3}

\todo{write a text from the following notes}

global versions (JS execution: single-threaded, cooperative scheduling), linear versioning (for now), data structure is an version object with a predecessor and a successor

version dictionary: version identifier (runtime version) -> version object

The version also may have a predecessor and a successor.
This way, for undo and redo the current version of the runtime only has to be set on the predecessor or the successor.
Preserving the predecessor also allows to preserve versions of objects only on writes as, when objects have not changed in versions, the first available previous version of the object can be read.



When a proxy is created for an object, the object is preserved as the version of the object that belongs to the current version of the runtime.
On writes, the proxies copy the latest version of the object and then do the write on the copy instead.
The copy gets marked with the identifier of the new version of the runtime.
When the proxies now choose a particular version of the object they stand-in for, they all use the version associated with the current version of the runtime or of a previous versions.

copy-on-write for versions of objects: set-trap, apply-trap for some array methods
shallow copy
Besides this copy-on-write optimization, another optimization would be to not copy objects completely, but to only store changes.
this could, for example, also apply prototypical inheritance to have versions that delegate to previous versions and only express the differences between versions.



some additional logic is required to update state that is not part of the runtime state as, for example, the HTML document presented by browsers.
redraw of the world as DOM objects / DOM relations are not part of the object versioning in JavaScript: DOM redrawing on undo / redo: DOM is out of versioning scope, doesn’t use version-aware references, has to be changed / redrawn on undo/redo explicitly




\section{Proxies For All Mutable JavaScript Objects}

As we use proxies as version-aware references while the JavaScript runtime still only provides ordinary references, references that usually would point to objects directly now need to point to proxies instead. 
References to the same object need to point to the same proxy for that object as the identity of proxies will be compared instead of the identity of the original objects.
Also, as proxies actually hold the different versions of their objects as opposed to looking the objects up in a separate data structure in our implementation, one particular proxy knows the versions of an object.
Therefore, all references that would normally refer to the object need to refer to the proxy that stands-in for all the versions of the objects.
To achieve this, we create proxies immediately for new objects and return the proxies instead of the objects, so a reference to the proxy gets passed around instead of the reference to the actual object, which instead is captured as a version in the versions dictionary of the proxy.

We need to create proxies for all new mutable state, which in JavaScript comprises of objects, arrays, and functions.
Also for functions as functions are also objects and can have properties in JavaScript.
JavaScript allows to create these kinds of objects through literal expressions, constructors, and built-in functions.
Constructors can be built-in as, for example, \lstinline{Array} or created from literals.
Both create new objects when applied with the \lstinline{new} keyword, but built-in constructors also return new objects when applied without the \lstinline{new} operator.
Other built-in functions are, for example, \lstinline{eval()} or \lstinline{Object.create()}.
To create and return proxies from all these three different ways to create objects, our implementation transforms sources before execution.
The built-in functions could be overwritten globally to return proxies for the new objects, but our implementation of object versioning is itself just a JavaScript library and makes itself use of the built-in data types.
Additionally, at the time of writing, some JavaScript engines do not allow to overwrite particular built-in functions and we want our implementation of object versioning to work in every JavaScript engine that supports the ECMAScript 6 Direct Proxies.
Therefore, we transform specific literal expressions and specific built-in functions, while custom constructors return proxies through proxy trap behavior.

The source transformations for introducing our proxy-based version-aware references wrap the original expressions into the \lstinline{proxyFor} function, which returns a proxy for an object.
The transformations of literal objects, arrays, and functions are shown by example in the following table.

\begin{center}
    \begin{tabular}{| l | l | l | l |}
    \hline
    Type & Original code & Transformed code \\ \hline
    \emph{Objects} & \lstinline|{name: 'James', age: 24}| & \lstinline|proxyFor(name: 'James', age: 24)| \\ \hline
    \emph{Arrays} & \lstinline|[person1, person2]| & \lstinline|proxyFor([person1, person2])| \\ \hline
    \emph{Functions} & \lstinline|function (a, b) {..}| & \lstinline|proxyFor(function (a, b) {..})| \\ \hline
    \end{tabular}
\end{center}

Besides straightforward wrapping of literal objects, literal arrays, and function expressions, the source transformations also needs to handle function declarations and accessor functions.
Function declarations are named functions, where the name is available for recursion in the function itself and also makes the function accessible by the name in the surrounding scope.
For this reason, the function declaration get transformed to function expressions that are assigned to matching variable names.
This way, \lstinline|function funcName(..) {..}| becomes \lstinline|var funcName = function funcName(..) {..}|.
In addition, because function declarations get hoisted in JavaScript, the source transformation moves the results of transforming function declarations to the beginning of the defining scope, while preserving the original order of function declarations.
Accessor functions are functions that are executed instead of ordinary read or write access to properties.
The following example snippet shows the definition of a \lstinline{person} object, where two accessor functions allow reading and writing \lstinline{person.age} while the value is stored under a slightly different name: \\
\iffalse
\begin{verbatim}\fi
\begin{code}{}{}
var person = {
    __age: 0,
    get age() {
        return this.__age;
    },
    set age(val) {
        this.__age = val;
    }
}
\end{code}
\iffalse
\end{verbatim}\fi

Wrapping the two accessor functions in-place into \lstinline{proxyFor} functions does not yield valid JavaScript code.
Therefore, the source transformations create the objects first without accessor functions and explicitly define the accessor functions using \lstinline{Object.defineProperty} later-on.
These two steps are done in an anonymous functions that is applied directly, to use a temporary variable for the newly created object to be able to refer to it in the \lstinline{Object.defineProperty}-function call, while not polluting the originally surrounding scope with an implementation-specific temporary variable.
That is, the presented example with accessor functions would be transformed to the following code: \\

\iffalse
\begin{verbatim}\fi
\begin{code}{}{}
var person = function() {
    var newObject = lively.proxyFor({
        __age: 0;
    });
    Object.defineProperty(newObject, "age", {
        get: lively.proxyFor(function age() {
            return this.__age;
        }),
        set: lively.proxyFor(function age(val) {
            this.__age = val;
        }),
        enumerable: true,
        configurable: true
    });
    return newObject;
}();'
\end{code}
\iffalse
\end{verbatim}\fi

Similar to the wrapping of object literals without accessor functions, of arrays, and of function expressions, the source transformation also wraps specific built-in functions into plain calls to the \lstinline{proxyFor()} function.
For example, \lstinline{Array(100)} becomes \lstinline{proxyFor(Array(100))}.
As every call to such built-in objects is transformed in this way, the same Object---in this case the \lstinline{Array} function---gets passed to the \lstinline{proxyFor} function multiple times.
To nevertheless return the same proxy, which also is necessary for identity checks when compared with references that go through proxies, we use a map that associates objects with their proxies.
This \emph{Proxy Table} is a weak-key map and does prevent the version object used as keys from being gargabe collected when their proxies get garbage collected.
Therefore, the following statement yields true for an arbitrary object \lstinline{obj}: \lstinline{proxyFor(obj) === proxyFor(obj)}.

When objects get created through applying functions with the \lstinline{new} operator, the freshly created objects also need to be proxied.
However, as the functions are already proxied through source transformations of function literals and the built-in \lstinline{Function} constructor, our implementation does not transform the applications of the \lstinline{new} operator, but uses the \emph{construct} trap to return proxies from constructor applications.
The last line of code of the \lstinline{construct} function of our proxy handler is therefore: \lstinline{return this.ensureProxied(newInstance)}.
This is also true for the \emph{apply} trap, because, for example, the \lstinline{Array} and \lstinline{Object} functions also create objects when called without the \lstinline{new} operator and, for example, the built-in function \lstinline{Object.create(proto)} also returns a new object.
In fact, with our proxy handler the \emph{get}-trap also makes sure to return always proxy in this fashion.
So, wrapping \lstinline{Object} is enough to have \lstinline{Object.create(proto)} return a proxy: \lstinline{Object.create(proto)} transforms to \lstinline{proxyFor(Object).create(proto)} and getting the property \emph{create} then returns a proxy for the function, which when applied also returns a proxy.

The implementation of source transformations uses \emph{UglifyJS}\footnote{\url{http://github.com/mishoo/UglifyJS2}, accessed March 12, 2014} for parsing and for all AST transformations.
UglifyJS parses without relying on JavaScript exceptions for, for example, backtracking and, therefore, does not interfere with debugging.
In addition, UglifyJS also supports Source Maps \todo{footnote with url to Source Maps}, which allow to view and debug the original code with the browser's developer tools, even though the transformed code is executed.


\todo{add something about when the versioning source transformations are done and which parts of the system are currently versioned}
% TODO: source transformations enabled right after the object versioning code, i.e. the implementation of the proxies and the source transformation, which are both themselves implemented using ordinary javascript code, gets loaded. by patching the eval that is used for evaluated modules that get loaded with an eval(transformSource.. so modules are not versioned, but classes / layers / traits are.. e.g. a class is versioned, so in different versions there might be different class-side state... so, for example, modules are currently in our implementation the roots of the version-aware reference graphs that prevent garbage collection, 





\section{Workarounds for this Usage of the Current State of the Proxies}

Certain workarounds are required to make our proxy-based implementation of version-aware references work, due to the preliminary status of the proxy implementation.
While the specification of Direct Proxies already progressed from proposal status to being part of the current ECMAScript 6 Draft\footnote{\url{http://people.mozilla.org/~jorendorff/es6-draft.html}, accessed March 5th, 2014}, it is still in draft status and not yet implemented in the JavaScript engines used by the Chrome browser and the Firefox browser.
These two engines currently both implement two different deprecated proposals for the proxies instead of the most recent ECMAScript 6 Draft.
The \emph{harmony-reflect} library\footnote{\url{http://github.com/tvcutsem/harmony-reflect}, accessed February 3, 2014, used version 0.0.11}, however, provides the current API of Direct Proxies for recent versions of both Chrome and Firefox, on top of the implementations of the different deprecated proposal states.
That is, our versioning proxies prinicipally work in both Chrome and Firefox and rely on the \emph{harmony-reflect} shim for this.
However, even with the shim, two issues need to be addressed with technical workarounds that might no longer be necessary once ECMAScript 6 standard gets finalized and fully implemented by the JavaScript engines: 

\begin{enumerate}
    \item The proxies have to be provided with an actual target, even when implementing virtual objects and consistency checks compare return values of traps to the state of the actual target. 
    \item Certain built-in JavaScript functions dont handle proxies correctly.
\end{enumerate}

\todo{add the missing instanceof operator trap}


\subsection{Fixed Target Objects for Proxies}

Using the \emph{harmony-reflect} shim in a recent Chrome, proxies require an actual \emph{target} object even though the current ECMAScript 6 draft says otherwise\footnote{\url{http://people.mozilla.org/~jorendorff/es6-draft.html\#sec-proxy-object-internal-methods-and-internal-slots}, accessed April 15, 2014}.
When an actual target object is, however, provided when creating a proxy, the internal link between proxy and target object cannot be changed at runtime.
Therefore, in our use case of the proxies, in which proxies stand-in for a dynamically chosen version object among a group of different versions of one conceptionally one object, the proxy is now linked to a particular object or even particular version and delegates to that one by default.
Further, the Direct Proxies are designed to ensure certain invariants~\cite{Cutsem2013TRP} between an objects properties and the return values of traps when the object properties get accessed.
For example, one invariant is that a proxy's \lstinline{get}-trap has to return the fixed value for a property of an object that is configured to be immutable.
That is, in our case, when a versioning proxy is linked to a particular object as its target and that target cannot be changed after creating the proxy, configuring any property as immutable would effectively declare that property immutable for all versions.
Additionally, in this scenario, reading the property in a version where the value of this property is different from what it is in the immutable target would raise incosistency errors.
For this reason, we adapted our copy of the \emph{harmony-reflect} library.
In particular, we added a boolean flag to the Proxy constructor function that indicates whether a proxy is standing in for one target object or is a virtual object.
This boolean flag is then used to disable all consistency checks whenever a proxy is meant to be a virtual object.
Therefore, we provide the flag when creating versioning proxies.
The proxy constructor still requires an actual object as \emph{target} object, but this target object is only used for the \lstinline{typeof} operator for the virtual object-kind of proxies.
The \lstinline{typeof} operator returns only a distinction between a certain set of types in JavaScript, while our versioning proxies also stand-in only for certain mutable types.
In fact, the only necessary difference for the \lstinline{typeof} operator is that a proxy representing the versions of an object or array is an object has an object as target, while a proxy representing the versions of a function needs to have a function as target.
This difference in the type of supplied target objects is also necessary as the \emph{apply}- and \emph{construct}-trap are also only called on proxies with functions as targets.

\todo{add a Figure that adds this (dummy-)target link to the existing proxy+proxy handler (with traps) and link to versions.. where the target obviously is out of place + redundant}



\subsection{Unwrapping Versions for Native Code}

Some built-in functions react to proxies with actual errors, return wrong results, or otherwise do not provide the usual functionality.
Therefore, these functions need to be provided with actual objects instead of the proxy.
This is unproblematic for most cases as, given JavaScript's single-threaded and cooperative execution in browser engines, which version of an object is to be used is not expected to change during the execution of a built-in function.
Our implementation provides the current version of an object to these built-in functions through proxy handler traps and patched built-in functions.
The \emph{apply}-trap, called when proxied functions get applied, unwraps all arguments and the \emph{thisContext} object, when the applied function is a built-in functions that does not handle proxies.
This is for example the case for the functions that provide access to the browser's document model.
Further, the \emph{set}-trap sometimes needs to unwrap the assigned value when that value is proxied and gets assigned to slots that cannot handle proxies.
This is for example the case with the \lstinline{onreadystatechange} slot of \emph{XMLHttpRequest} objects.
This particular slot holds functions as callbacks of asynchronous HTTP requests, which, however, do not get called when these functions are proxies.
This is particular case is potentially problematic.
Though JavaScript does get executed with a single thread  using cooperative scheduling by all popular browsers, other concurrent scripts might get executed before a script ends whenever a script is waiting on I/O like, for example, an asynchronous request to finish.
As this---changing a callback function or its properties while waiting on the response---is unlikely, bad programming style as it introduces dependencies to the timing of network I/O, and is through network communication already at the limit of what object versioning can due in general, our implementation currently does not provide a workaround for this specific case, even though we are aware of this potential problem. 
In addition to these behavior implemented in traps, there are also certain immutable types that do not get proxied at all in our implemention as, for example, strings.
However, some methods of, for example, string objects also do not handle proxies correctly and our implementation, therefore, patches those functions to also unwrap proxies before executing the original functions.

\todo{add something on our way to detect native code}


\subsection{Forwarding the \emph{Instanceof} Operator}

There currently is no \lstinline{instanceof} trap to intercept the behavior of the \lstinline{instanceof} operator since the Direct Proxies currently do not provide such a trap.
However, the type of an object in JavaScript is defined by an object's prototype chain, which may change at runtime.
So, while the prototype of an object is a property and gets versioned as well, the \lstinline{instanceof} operator does not get trapped and, thus, is not delegated to the current version of the object when used on a proxy.
When creating a proxy a \emph{target} object can be provided to be linked from the proxy and the \lstinline{instanceof} operator would follow this link to report the target's type, but as the target link cannot be changed later on, while proxies stand-in for multiple versions with potentially different types, this is not an option.
Therefore, the \lstinline{instanceof} access needs to be handled by a custom \lstinline{Object.instanceof()} function, which implments the semantics of JacaScript's \lstinline{instanceof} operator but does delegate the necessary checks when a versioning proxy gets passed to it.
To exchange all usage of the \lstinline{instanceof} operator with application of this custom function, we transform JavaScript sources before execution.
These transformations change, for example, \lstinline{anObject instanceof SomeConstructor} to \lstinline{Object.instanceof(anObject, SomeConstructor)}.



\section{Limitations of the Implementation}

\todo{write this section from the following notes}

% content: limitations of our implementation that are not directly related to the state of the preliminary implementation of the proxies.. except for the general limitation that these proxies have to be available, e.g. experimental javascript enabled in chrome

our implementation is based on and requires the ECMAScript 6 Direct Proxies to be available.
however, as these are at the moment only part of the next draft of ECMAScript and not yet finalized, the implementation only works when the nevertheless are available, which is currently.. recent versions of Chrome with experimental JavaScript explicitly enabled and in recent versions of Firefox


% TODO: Limitations for Concurrent JavaScript

single-threaded and cooperative scheduling, but setTimeout / setInterval... stop asynchronous actions from following versions when undoing... source transformations, which scripts belongs to which version



% TODO: Usability: Impact on Debugging

adds lots of low-level frames due to the partly native but also partly shim implementation of proxies..

dev tools don’t yet handle proxies well (hovering, labels, stepping into), but we have at least source maps, so developers can debug the original code and not the result of our source transformation
Besides impacting code execution, the current implementation of object versioning for Lively also with certain programming tasks.
Though the version-aware references should be transparent to programmers, in the current proxy-based implementation proxies show during debugging.
However, the developer tools show the original source code, despite the implementation's transformations of the sources.





Nevertheless, our implementation is functional and integrated with Lively.
It allows programmers to undo and redo changes and is publicly available\footnote{\url{http://github.com/LivelyKernel/LivelyKernel/commit/858aca8c5ac0f203061823f463fda9b434131636}}.
