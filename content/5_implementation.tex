\chapter{Implementation with Proxies} \label{chapter:IMPLEMENTATION}

We implemented version-aware references for object versioning in JavaScript, using proxies and source transformations.
That is, our prototype does not require changes to the JavaScript engines, but only a certain JavaScript language feature.
In particular, it requires the Direct Proxies\footnote{\url{http://wiki.ecmascript.org/doku.php?id=harmony:direct_proxies}, accessed February 3rd, 2014} feature proposed with the Version 6 of ECMAScript, the standard that JavaScript follows, which is already partly available in multiple browsers at the time of writing.

These proxies can handle all kinds of access with specific behavior, which we used to delegate the access to a particular version of the object the proxy stands-in for.
To have these proxies intercept access to all mutable objects, for which multiple versions may exist, a combination of source transformations and proxy behavior ensures that proxies are returned instead of objects whenever new objects are created.
The proxies also preserve and choose versions of their object corresponding to a global version identifier.
This version identifier effectively establishes a particular state of the programming runtime and programmers can undo and redo all kinds of changes by changing the identifier.
However, some additional logic is required to update state that is not part of the runtime state as, for example, the HTML document presented by browsers.

As the direct proxy specification is preliminary---already progressed towards the Draft ECMAScript 6\footnote{\url{http://people.mozilla.org/~jorendorff/es6-draft.html}, accessed March 5th, 2014}, which is, however, still in draft status and not yet finalized---a few additional workarounds are necessary for our use case of the proxies.
Further, the proxies are not fully implemented in all browsers, yet, and some built-in browser tools for developers also do not support them entirely.
Nevertheless, our implementation is functional and integrated with Lively.
It allows programmers to undo and redo changes and is publicly available\footnote{\url{http://github.com/LivelyKernel/LivelyKernel/commit/e8a9c091d25be4e3d556717080020b8fa7d93929}}.



\section{Using ECMAScript 6 Direct Proxies}

proxies for mutable state: JavaScript objects: objects, arrays, functions
proxies know versions and can delegate access transparently to one of many versions

ECMAScript 6 Direct Proxies: proxy handler object,
traps;
% ES6 in DRAFT~\cite{ECMA2014ES6}
deprecated Harmony Proxy proposal implemented in current chromes

fully virtual objects traps to specify proxy behavior, traps for property reads, property writes, accessing the prototype, other meta programming...



ECMAScript 6 Direct Proxies: fully virtual objects, traps to specify proxy behavior, traps for property reads, property writes, accessing the prototype, other meta programming... where we delegate each of those actions to the current version


\begin{itemize}
    \item the proxy handlers really hold references to copies of the same object in a dictionary (version name -> object version)
    \item delegation to a particular version at runtime using a version of the target object according to some global version of the runtime..
    \item identity of proxyFor(obj) === proxyFor(obj), ProxyTable (weak-key map, objects -> to their proxies)
\end{itemize}



proxy implementation limitations: 
\begin{itemize}
    \item [native code] boundary / primitive functions and objects: setting properties / calling functions leads to errors or has absolutely no effect: part 1: traps (sep-trap: onreadystatechange, apply-trap: any DOM function.., Array.prototype.concat, aWorker.postMessage.. multi-level unwrapping for args object, aFunc.apply or aFunc.call).
part 2: patches: Object.isRegExp, some string.match (done by patching String.prototype.match)
    \item proxies as prototypes (relation cant be changed.. traps of proto fire when inheriting object is accessed.. problem is Chrome and only the proto case...)... protoProxy property on objects..
\end{itemize}


no instanceof trap, Object.instanceOf source transformation 







\section{Returning Proxies For New Objects}

goal: all references to newly created objects need to be version-aware references, i.e. references to proxies instead of references to the (initial version of the) target. 

we rewrite instead of patching them globally, because that's not possibly for all built-in objects.
also, our implementation is itself in javascript and, therefore, uses built-in data types, too, which should not be proxied.
for this reasons, we transform the sources of modules loaded after our versioning implementation.

\begin{itemize}
    \item value of literal expressions: source transformations (objects, arrays, function expressions), examples.. function declarations and hoisting, literal accessor functions in object literals
    \item return value of custom constructors: construct-trap (..code for the construct / apply traps of the proxies..)
    \item return value of specific built-in functions and constructors: source transformations (only in the lexical scope of some particular modules, e.g. not for our implementation)
\end{itemize}

[what about all other source transformations..??]

% why UglifyJS?: fast, complete, testing alternative grammar rules during parsing is not implemented using execeptions, provides source maps (all in contrast to OMeta)



\section{Providing Simple Global Versions for Undo and Redo}

JS execution: single-threaded, cooperative scheduling 

\begin{itemize}
    \item global versions, linear versioning, data structure is an version object with a predecessor and a successor
    \item copy-on-write for versions of objects (set-trap, apply-trap for some array methods), shallow copy
\end{itemize}


\begin{itemize}
    \item source transformations enabled right after the object versioning code, i.e. the implementation of the proxies and the source transformation, which are both themselves javascript code, gets loaded. by patching the eval that is used for evaluated modules that get loaded with an eval(transformSource.. so modules aren’t versioned, but classes / layers / traits are.. e.g. a class is versioned, so in different versions there might be different class-side state... so, for example, modules are currently in our implementation the roots of the version-aware reference graphs that prevent garbage collection, 
\end{itemize}


\begin{itemize}
    \item undo / redo implementation, example situation
    \item redraw of the world as DOM objects / DOM relations are not part of the object versioning in JavaScript: DOM redrawing on undo / redo: DOM is out of versioning scope, doesn’t use version-aware references, has to be changed / redrawn on undo/redo explicitly
    
\end{itemize}






\section{Limitations of the Implementation}


% \subsection{Limitations for Concurrent JavaScript}


single-threaded and cooperative scheduling, but setTimeout / setInterval... stop asynchronous actions from following versions when undoing... source transformations, which scripts belongs to which version


% \subsection{Limitations in the Execution Environment}

\begin{itemize}
    \item only works in recent Chromes, with experimental JavaScript... ECMAScript 6 Direct Proxies not yet fully implemented, not yet stable.. shim library\footnote{\url{http://github.com/tvcutsem/harmony-reflect}, accessed February 3, 2014, at version 0.0.11}..
.. own adaptions to the shim library, to bridge the gap between the current version of the shim and information from the Spec draft (pass null for the target of a proxy)... fully virtual objects vs. consistency checks.. adapted library to fit spec draft (pass null as target of a fully virtual object, then no trap-return-value-consistency-with-target checks)
\end{itemize}
    





% \subsection{Usability: Impact on Debugging}

\begin{itemize}
    \item adds lots of low-level frames, dev tools don’t handle proxies well (hovering, labels, stepping into), but we have at least source maps, so developers can debug the original code and not the result of our source transformation
    \item debugging: interference with Chrome's developer tools, which don’t handle proxies well (hovering, labels, stepping into)
\end{itemize}


Besides impacting code execution, the current implementation of object versioning for Lively also  with certain programming tasks.
Though the version-aware references should be transparent to programmers, in the current proxy-based implementation proxies show during debugging.
However, the developer tools show the original source code, despite the implementation's transformations of the sources.
