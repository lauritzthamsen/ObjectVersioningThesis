\chapter{Implementation with Proxies} \label{chapter:IMPLEMENTATION}

% additional TODO: .call + .apply
% and TODO: [what about all other source transformations..??]


We implemented version-aware references for object versioning in JavaScript, using proxies and source transformations.
That is, our prototype does not require changes to the JavaScript engines, but only a certain JavaScript language feature.
In particular, it requires the Direct Proxies\footnote{\url{http://wiki.ecmascript.org/doku.php?id=harmony:direct_proxies}, accessed February 3rd, 2014} feature proposed with the Version 6 of ECMAScript, the standard that JavaScript follows, which is already partly available in multiple browsers at the time of writing.

These proxies can handle all kinds of access with specific behavior, which we used to delegate the access to a particular version of the object the proxy stands-in for.
To have these proxies intercept access to all mutable objects, for which multiple versions may exist, a combination of source transformations and proxy behavior ensures that proxies are returned instead of objects whenever new objects are created.
The proxies also preserve and choose versions of their object corresponding to a global version identifier.
This version identifier effectively establishes a particular state of the programming runtime and programmers can undo and redo all kinds of changes by changing the identifier.
However, some additional logic is required to update state that is not part of the runtime state as, for example, the HTML document presented by browsers.

As the direct proxy specification is preliminary---already progressed towards the Draft ECMAScript 6\footnote{\url{http://people.mozilla.org/~jorendorff/es6-draft.html}, accessed March 5th, 2014}, which is, however, still in draft status and not yet finalized---a few additional workarounds are necessary for our use case of the proxies.
Further, the proxies are not fully implemented in all browsers, yet, and some built-in browser tools for developers also do not support them entirely.
Nevertheless, our implementation is functional and integrated with Lively.
It allows programmers to undo and redo changes and is publicly available\footnote{\url{http://github.com/LivelyKernel/LivelyKernel/commit/858aca8c5ac0f203061823f463fda9b434131636}}.



\section{Using ECMAScript 6 Direct Proxies}

Our implementation of version-aware references is based on the ECMAScript 6 Direct Proxies.
These are supposed to stand-in for a particular object, but also can be used as fully virtual objects instead.
In our case, the proxies represent multiple different versions of an object and do not delegate to any of those by default.
Instead, they choose a particular version to delegate access to.
The proxying behavior can be specified in a \emph{Handler} object, which has to be provided when creating proxies.
Which kind of access is to be handled how is defined in so called \emph{Traps}, methods of the proxy handler that are called for different access.
For example, when \lstinline{person} is a proxy and \lstinline{person.age} is called, the \emph{get}-trap fires.
The \emph{get}-trap looks like \lstinline{function get(target, name, receiver)}.
In our example, the \emph{target} parameter would be irrelevant as we use proxies as virtual objects, not to be associated with any particular object, whereas the \emph{name} would be the property name \'age\' and \emph{receiver} would be the proxy referred to by \emph{person} again.

Our proxy handler's \emph{get}-trap  like indicated by the following code snippet, which is simplified and leaves out handling of special cases due to the proxy implementation's shortcomings:

\iffalse
\begin{verbatim}\fi
\begin{code}{}{}
get: function(.., name, receiver) {
    var version = this.currentVersion();
    
    if (name === 'isProxy') {
    // more special cases...
    
    result = version[name];
    
    return this.ensureProxied(result);
}
\end{code}
\iffalse
\end{verbatim}\fi

Besides the \emph{get}-trap, our proxy handler similarly provides behavior for all of the traps: \lstinline{set}, \lstinline{apply}, \lstinline{construct}, \lstinline{has}, \lstinline{hasOwn}, \lstinline{defineProperty}, \lstinline{deleteProperty}, \lstinline{getOwnPropertyDescriptor}, \lstinline{getOwnPropertyNames}, \lstinline{getPrototypeOf}, \lstinline{freeze}, \lstinline{seal}, \lstinline{preventExtensions}, \lstinline{isFrozen}, \lstinline{isSealed}, \lstinline{isExtensible}, \lstinline{enumerate}, \lstinline{keys}.
All these traps fire for specific operators or meta-programming facilities provided by the built-in global \emph{Object}\footnote{\url{http://wiki.ecmascript.org/doku.php?id=harmony:direct_proxies\#api}, accessed March 5, 2014}.


Besides these functions, the proxy handler also holds all versions of the objects they represent.
For this, the proxy handler uses an object as dicitionary that associates version identifiers with the different versions of the object.



deprecated Harmony Proxy proposal implemented in current chromes

proxy implementation limitations:
no instanceof trap, Object.instanceOf source transformation

\begin{itemize}
    \item [native code] boundary / primitive functions and objects: setting properties / calling functions leads to errors or has absolutely no effect: part 1: traps (sep-trap: onreadystatechange, apply-trap: any DOM function.., Array.prototype.concat, aWorker.postMessage.. multi-level unwrapping for args object, aFunc.apply or aFunc.call).
part 2: patches: Object.isRegExp, some string.match (done by patching String.prototype.match)
    \item proxies as prototypes (relation cant be changed.. traps of proto fire when inheriting object is accessed.. problem is Chrome and only the proto case...)... protoProxy property on objects..
\end{itemize}










\section{Returning Proxies For New Objects}

As we use proxies as version-aware references while the JavaScript runtime still only provides ordinary references, references that usually would point to objects directly now need to point to proxies instead. 
References to the same object further need to point to the same proxy for that object.
This is necessary because identity checks will compare proxies instead of objects.
Also because, at least in our implementation, proxies actually hold the different versions of their objects as opposed to looking the objects up in a separate data structure, one particular proxy knows the versions of an object.
Therefore, all references that would normally refer to the object need to refer to the proxy that stands-in for the versions of the objects.
To achieve this, we create proxies immediately for new objects and return the proxies instead of the objects, so a reference to the proxy gets passed around instead of the reference to the actual object, which instead is captured in the versions dictionary of the proxy.

We need to create proxies for all new mutable state, which in JavaScript comprises of objects, arrays, and functions.
JavaScript allows to create these kinds of objects through literal expressions, through constructors, and through built-in functions.
That is, functions are objects and can also have properties in JavaScript.
Constructors can be built-in as, for example, \lstinline{Array} or literal functions.
Both create new objects when applied with the \lstinline{new} keyword, however built-in constructors also return new objects when applied without the \lstinline{new} operator.
Other built-in functions are, for example, \lstinline{eval} or \lstinline{Object.create(..)}.
To actually create and return proxies from all these three different ways to create objects, our implementation transforms sources before execution.
The built-in functions could be overwritten globally to return proxies for the new objects, but our implementation of object versioning also uses these built-in data types internally.
Additionally, at the time of writing, some JavaScript engines do not allow to overwrite particular built-in functions, while we want our implementation of object versioning to work in every JavaScript engine that supports ECMAScript 6 Direct Proxies.
Therefore, we transform specific literal expressions and specific built-in functions, while custom constructors return proxies through particular proxy trap behavior.

The source transformations for introducing our proxy-based version-aware references wrap the original expressions into the \lstinline{proxyFor} function, which returns a proxy for an object.
The transformations of literal objects, arrays, and functions are shown by example in following table.

\begin{center}
    \begin{tabular}{| l | l | l | l |}
    \hline
    Type & Original code & Transformed code \\ \hline
    \emph{Objects} & \lstinline|{name: 'James', age: 24}| & \lstinline|proxyFor(name: 'James', age: 24)| \\ \hline
    \emph{Arrays} & \lstinline|[person1, person2]| & \lstinline|proxyFor([person1, person2])| \\ \hline
    \emph{Functions} & \lstinline|function (a, b) {..}| & \lstinline|proxyFor(function (a, b) {..})| \\ \hline
    \end{tabular}
\end{center}

Besides straightforward wrapping of literal objects, literal arrays, and function expressions, the source transformations also needs to handle function declarations and accessor functions.
Function declarations are named functions, where the name is available for recursion in the function itself, but also makes the function accessible by the name in the surrounding scope.
For this reason, the function declaration get transformed to function expressions that are assigned to matching variable names.
This way, \lstinline|function funcName(..) {..}| becomes \lstinline|var funcName = function funcName(..) {..}|.
In addition, because function declarations get hoisted in JavaScript, the source transformation moves the results of transforming function declarations to the beginning of the defining scope, while the order among function declaration is preserved.
Accessor functions are functions that are executed instead of ordinary read or write access to properties.
The following example snippet shows the definition of a \lstinline{person} object, where two accessor functions allow reading and writing \lstinline{person.age} while the value is stored under a different name: \\
\iffalse
\begin{verbatim}\fi
\begin{code}{}{}
var person = {
    __age: 0,
    get age() {
        return this.__age;
    },
    set age(val) {
        this.__age = val;
    }
}
\end{code}
\iffalse
\end{verbatim}\fi

Wrapping the two accessor functions in-place into \lstinline{proxyFor} functions does not yield valid JavaScript code.
Therefore, the source transformations wrap object literals with accessor functions into anonymous functions that are directly applied, create the objects first without accessor functions, and explicitly define the accessor functions using \lstinline{Object.defineProperty}.
That is, the presented example with accessor functions would be transformed to the following code: \\

\iffalse
\begin{verbatim}\fi
\begin{code}{}{}
var person = function() {
    var newObject = lively.proxyFor({
        __age: 0;
    });
    Object.defineProperty(newObject, "age", {
        get: lively.proxyFor(function age() {
            return this.__age;
        }),
        set: lively.proxyFor(function age(val) {
            this.__age = val;
        }),
        enumerable: true,
        configurable: true
    });
    return newObject;
}();'
\end{code}
\iffalse
\end{verbatim}\fi

Similar to the wrapping of object literals without accessor functions, arrays, and function expressions, the source transformation also wraps specific built-in functions into calls to the \lstinline{proxyFor()} functions.
For example, \lstinline{Array(100)} becomes \lstinline{proxyFor(Array(100))}.
As every call to such built-in objects is transformed in this way, the same Object---in this case the \lstinline{Array} function---gets passed to the \lstinline{proxyFor} function multiple times.
To nevertheless return the same proxy and, therefore, the same identity, we use a map that associates objects with their proxies.
This \emph{Proxy Table} is a weak-key map and does not prevent neither objects nor proxies from being gargabe collected.
Therefore, the following statement returns true for an arbitrary object \lstinline{obj}: \lstinline{proxyFor(obj) === proxyFor(obj)}.

When objects get created through applying functions with the \lstinline{new} operator, the new objects also need to be proxied.
However, as the functions are already proxied through source transformations of function literals and the built-in \lstinline{Function} constructor, our implementation does not transform the applications of the \lstinline{new} operator, but uses the \emph{construct} trap to return proxies from constructor applications.
The last line of code of the \lstinline{construct} function of our proxy handler is therefore: \lstinline{return this.ensureProxied(newInstance)}.
This is also true for the \emph{apply} trap, because, for example, the \lstinline{Array} and \lstinline{Object} functions also create objects when called without the \lstinline{new} operator and, for example, the built-in function \lstinline{Object.create(proto)} also returns a new object.
In fact, with our proxy handler the \emph{get}-trap also makes sure to return always proxy in this fashion.
So, wrapping \lstinline{Object} is enough to have \lstinline{Object.create(proto)} return a proxy: \lstinline{Object} transforms to \lstinline{proxyFor(Object)}, while getting the property returns a proxy for the \emph{create} function, and applying that in turn also returns a proxy.

The implementation of source transformations uses \emph{UglifyJS}\footnote{\url{http://github.com/mishoo/UglifyJS2}, accessed March 12, 2014} for parsing and AST transformations.
UglifyJS parses without using JavaScript exceptions for backtracking and, therefore, does not interfere with debugging.
In addition, UglifyJS also supports Source Maps \todo{footnote with url to Source Maps necessary..}, which allow to view and debug the original code with the browser's developer tools, even though the transformed code is executed.



\section{Providing Simple Global Versions for Undo and Redo}

JS execution: single-threaded, cooperative scheduling 

\begin{itemize}
    \item global versions, linear versioning, data structure is an version object with a predecessor and a successor
    \item copy-on-write for versions of objects (set-trap, apply-trap for some array methods), shallow copy
\end{itemize}


\begin{itemize}
    \item source transformations enabled right after the object versioning code, i.e. the implementation of the proxies and the source transformation, which are both themselves javascript code, gets loaded. by patching the eval that is used for evaluated modules that get loaded with an eval(transformSource.. so modules aren’t versioned, but classes / layers / traits are.. e.g. a class is versioned, so in different versions there might be different class-side state... so, for example, modules are currently in our implementation the roots of the version-aware reference graphs that prevent garbage collection, 
\end{itemize}


\begin{itemize}
    \item undo / redo implementation, example situation
    \item redraw of the world as DOM objects / DOM relations are not part of the object versioning in JavaScript: DOM redrawing on undo / redo: DOM is out of versioning scope, doesn’t use version-aware references, has to be changed / redrawn on undo/redo explicitly
    
\end{itemize}






\section{Limitations of the Implementation}


% \subsection{Limitations for Concurrent JavaScript}


single-threaded and cooperative scheduling, but setTimeout / setInterval... stop asynchronous actions from following versions when undoing... source transformations, which scripts belongs to which version


% \subsection{Limitations in the Execution Environment}

\begin{itemize}
    \item only works in recent Chromes, with experimental JavaScript... ECMAScript 6 Direct Proxies not yet fully implemented, not yet stable.. shim library\footnote{\url{http://github.com/tvcutsem/harmony-reflect}, accessed February 3, 2014, at version 0.0.11}..
.. own adaptions to the shim library, to bridge the gap between the current version of the shim and information from the Spec draft (pass null for the target of a proxy)... fully virtual objects vs. consistency checks.. adapted library to fit spec draft (pass null as target of a fully virtual object, then no trap-return-value-consistency-with-target checks)
\end{itemize}
    





% \subsection{Usability: Impact on Debugging}

\begin{itemize}
    \item adds lots of low-level frames, dev tools don’t handle proxies well (hovering, labels, stepping into), but we have at least source maps, so developers can debug the original code and not the result of our source transformation
    \item debugging: interference with Chrome's developer tools, which don’t handle proxies well (hovering, labels, stepping into)
\end{itemize}


Besides impacting code execution, the current implementation of object versioning for Lively also  with certain programming tasks.
Though the version-aware references should be transparent to programmers, in the current proxy-based implementation proxies show during debugging.
However, the developer tools show the original source code, despite the implementation's transformations of the sources.
